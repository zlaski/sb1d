(***************************************************************************

   Input File:   MENUVIEW.OBJ
   Date/Time:    Tue Jan 12 00:03:33 2021
   -------------------------------------------------------

   Generated by Slim Binary(tm) Decoder Version 2.02

 ***************************************************************************)

MODULE MenuViewers;    (* Slim Binary(tm) *)

  IMPORT
    Viewers, Display, Objects, Input, Oberon;

  CONST
    extend = 1;
    invert = 2;
    minint = -32768;
    reduce = 0;
    replace = 0;

  TYPE
    ViewerDesc* = RECORD(Viewers.ViewerDesc)
      menuH*: INTEGER;
    END;
    Viewer* = POINTER TO ViewerDesc;
    ARRAYAE = ARRAY OF CHAR;

  VAR
    LightFrame: INTEGER;
    FullColor: INTEGER;
    DarkFrame: INTEGER;

  (* Forward PROCEDURE declarations *)

  PROCEDURE^ Change(V: Viewer; X: INTEGER; Y: INTEGER; Keys: SET);
  PROCEDURE^ Copy(V: Viewer; VAR V1: Viewer);
  PROCEDURE^ Draw(V: Viewers.Viewer);
  PROCEDURE^ Extend(V: Viewer; newY: INTEGER);
  PROCEDURE^ Grow(V: Viewer; oldH: INTEGER);
  PROCEDURE^ Init();
  PROCEDURE^ ModifyFrame(F: Display.Frame; id: INTEGER; dY: INTEGER; Y: INTEGER; H: INTEGER);
  PROCEDURE^ ModifyViewer(V: Viewer; id: INTEGER; Y: INTEGER; H: INTEGER);
  PROCEDURE^ Reduce(V: Viewer; newY: INTEGER);
  PROCEDURE^ Restore(V: Viewer);
  PROCEDURE^ Shrink(V: Viewer; newH: INTEGER);
  PROCEDURE^ Suspend(V: Viewer);
  PROCEDURE^ GetName*(V: Viewer; VAR name: ARRAYAE);
  PROCEDURE^ Handle*(V: Objects.Object; VAR M: Objects.ObjMsg);
  PROCEDURE^ New*(Menu: Display.Frame; Main: Display.Frame; menuH: INTEGER; X: INTEGER; Y: INTEGER): Viewer;

  PROCEDURE Change(V: Viewer; X: INTEGER; Y: INTEGER; Keys: SET);

    VAR
      keysum: SET;
      dY: INTEGER;
      Y0: INTEGER;
      V1: Viewers.Viewer;
      Menu: Display.Frame;
      Main: Display.Frame;
      H: INTEGER;

  BEGIN  (* PROCEDURE Change *)
    Menu := V^.dsc;
    Main := V^.dsc^.next;
    Oberon.DrawCursor(Oberon.Mouse, Oberon.Arrow, X, Y);
    Display.ReplConst(FullColor, V^.X + 1, (((V^.Y + V^.H) - 1) - Menu^.H), V^.W - 2, Menu^.H, 2);
    Y0 := Y;
    keysum := Keys;
    LOOP
      Input.Mouse(Keys, X, Y);
      IF (Keys = {}) THEN
        EXIT;
      END;  (* IF *)
      keysum := (keysum + Keys);
      Oberon.DrawCursor(Oberon.Mouse, Oberon.Arrow, X, Y);
    END;  (* LOOP *)
    Display.ReplConst(FullColor, V^.X + 1, (((V^.Y + V^.H) - 1) - Menu^.H), V^.W - 2, Menu^.H, 2);
    IF ~(0 IN keysum) THEN
      IF (1 IN keysum) THEN
        V1 := Viewers.This(X, Y);
        IF (V1 IS Viewer) & (Y > ((V1^.Y + V1^.H) - V1(Viewer)^.menuH)) THEN
          Y := (V1^.Y + V1^.H);
        END;  (* IF *)
        Viewers.Close(V);
        Viewers.Open(V, X, Y);
        Restore(V);
      ELSE
        IF (Y > Y0) THEN
          dY := (Y - Y0);
          V1 := Viewers.Next(V);
          IF (V1^.state > 1) THEN
            IF (V1 IS Viewer) THEN
              IF (V1^.H < (V1(Viewer)^.menuH + 1)) THEN
                dY := 0;
              ELSIF (V1^.H < ((V1(Viewer)^.menuH + 1) + dY)) THEN
                dY := ((V1^.H - V1(Viewer)^.menuH) - 1);
              END;  (* IF *)
            ELSIF (V1^.H < (1 + dY)) THEN
              dY := (V1^.H - 1);
            END;  (* IF *)
          ELSIF (V1^.H < dY) THEN
            dY := V1^.H;
          END;  (* IF *)
          Viewers.Change(V, ((V^.Y + V^.H) + dY));
          Oberon.RemoveMarks(V^.X, V^.Y, V^.W, V^.H);
          Grow(V, V^.H - dY);
          IF (V^.H > (V^.menuH + 1)) THEN
            ModifyFrame(Menu, 1, dY, ((V^.Y + V^.H) - V^.menuH), V^.menuH - 1);
            ModifyFrame(Main, 1, dY, V^.Y + 1, ((V^.H - V^.menuH) - 1));
          ELSE
            ModifyFrame(Menu, 1, dY, V^.Y + 1, V^.H - 2);
            ModifyFrame(Main, 1, dY, ((V^.Y + V^.H) - V^.menuH), 0);
          END;  (* IF *)
        ELSIF (Y < Y0) THEN
          dY := (Y0 - Y);
          IF (V^.H >= (V^.menuH + 2)) THEN
            IF (V^.H < ((V^.menuH + 2) + dY)) THEN
              dY := ((V^.H - V^.menuH) - 2);
            END;  (* IF *)
            Oberon.RemoveMarks(V^.X, V^.Y, V^.W, V^.H);
            H := (V^.H - dY);
            ModifyFrame(Main, 0, dY, V^.Y + 1, ((H - V^.menuH) - 1));
            ModifyFrame(Menu, 0, dY, ((V^.Y + H) - V^.menuH), V^.menuH - 1);
            Shrink(V, H);
            Viewers.Change(V, V^.Y + H);
          END;  (* IF *)
        END;  (* IF *)
      END;  (* IF *)
    END;  (* IF *)
  END Change;


  PROCEDURE Copy(V: Viewer; VAR V1: Viewer);

    VAR
      Menu: Display.Frame;
      Main: Display.Frame;
      M: Objects.CopyMsg;

  BEGIN  (* PROCEDURE Copy *)
    Menu := V^.dsc;
    Main := V^.dsc^.next;
    NEW(V1);
    V1^ := V^;
    V1^.state := 0;
    M.id := 0;
    Objects.Stamp(M);
    Menu^.handle(Menu, M);
    V1^.dsc := M.obj(Display.Frame);
    Main^.handle(Main, M);
    V1^.dsc^.next := M.obj(Display.Frame);
  END Copy;


  PROCEDURE Draw(V: Viewers.Viewer);

  BEGIN  (* PROCEDURE Draw *)
    Display.ReplConst(LightFrame, V^.X, V^.Y, 1, V^.H, 0);
    Display.ReplConst(LightFrame, V^.X + 1, ((V^.Y + V^.H) - 1), V^.W - 1, 1, 0);
    Display.ReplConst(DarkFrame, V^.X + 1, V^.Y, V^.W - 2, 1, 0);
    Display.ReplConst(DarkFrame, ((V^.X + V^.W) - 1), V^.Y, 1, V^.H - 1, 0);
  END Draw;


  PROCEDURE Extend(V: Viewer; newY: INTEGER);

    VAR
      dH: INTEGER;

  BEGIN  (* PROCEDURE Extend *)
    dH := (V^.Y - newY);
    IF (dH > 0) THEN
      Display.ReplConst(LightFrame, V^.X, newY, 1, dH, 0);
      Display.ReplConst(DarkFrame, ((V^.X + V^.W) - 1), newY, 1, dH, 0);
      Display.ReplConst(DarkFrame, V^.X + 1, newY, V^.W - 2, 1, 0);
    END;  (* IF *)
  END Extend;


  PROCEDURE Grow(V: Viewer; oldH: INTEGER);

    VAR
      dH: INTEGER;

  BEGIN  (* PROCEDURE Grow *)
    dH := (V^.H - oldH);
    IF (dH > 0) THEN
      Display.ReplConst(LightFrame, V^.X, V^.Y + oldH, 1, dH, 0);
      Display.ReplConst(LightFrame, V^.X + 1, ((V^.Y + V^.H) - 1), V^.W - 2, 1, 0);
      Display.ReplConst(DarkFrame, ((V^.X + V^.W) - 1), V^.Y + oldH, 1, dH, 0);
    END;  (* IF *)
  END Grow;


  PROCEDURE Init();

  BEGIN  (* PROCEDURE Init *)
    IF (Display.Depth(0) = 1) THEN
      LightFrame := 15;
    ELSE
      LightFrame := 0;
    END;  (* IF *)
    DarkFrame := 14;
    FullColor := 15;
  END Init;


  PROCEDURE ModifyFrame(F: Display.Frame; id: INTEGER; dY: INTEGER; Y: INTEGER; H: INTEGER);

    VAR
      M: Display.ModifyMsg;

  BEGIN  (* PROCEDURE ModifyFrame *)
    M.F := F;
    M.id := id;
    M.mode := 0;
    M.dlink := NIL;
    M.X := F^.X;
    M.Y := Y;
    M.W := F^.W;
    M.H := H;
    M.dX := 0;
    M.dY := dY;
    M.dW := 0;
    M.dH := (M.H - F^.H);
    M.res := -32768;
    M.x := 0;
    M.y := 0;
    Objects.Stamp(M);
    F^.handle(F, M);
    F^.Y := Y;
    F^.H := H;
  END ModifyFrame;


  PROCEDURE ModifyViewer(V: Viewer; id: INTEGER; Y: INTEGER; H: INTEGER);

    VAR
      Menu: Display.Frame;
      Main: Display.Frame;

  BEGIN  (* PROCEDURE ModifyViewer *)
    Menu := V^.dsc;
    Main := V^.dsc^.next;
    IF (id = 1) THEN
      Oberon.RemoveMarks(V^.X, Y, V^.W, V^.Y - Y);
      Extend(V, Y);
      IF (H > (V^.menuH + 1)) THEN
        ModifyFrame(Menu, 1, 0, ((Y + H) - V^.menuH), V^.menuH - 1);
        ModifyFrame(Main, 1, 0, Y + 1, ((H - V^.menuH) - 1));
      ELSE
        ModifyFrame(Menu, 1, 0, Y + 1, H - 2);
      END;  (* IF *)
    ELSIF (id = 0) THEN
      Oberon.RemoveMarks(V^.X, Y, V^.W, Y - V^.Y);
      IF (H > (V^.menuH + 1)) THEN
        ModifyFrame(Main, 0, 0, Y + 1, ((H - V^.menuH) - 1));
        ModifyFrame(Menu, 0, 0, ((Y + H) - V^.menuH), V^.menuH - 1);
      ELSE
        ModifyFrame(Main, 0, 0, ((Y + H) - V^.menuH), 0);
        ModifyFrame(Menu, 0, 0, Y + 1, H - 2);
      END;  (* IF *)
      Reduce(V, Y);
    END;  (* IF *)
  END ModifyViewer;


  PROCEDURE Reduce(V: Viewer; newY: INTEGER);

  BEGIN  (* PROCEDURE Reduce *)
    Display.ReplConst(DarkFrame, V^.X + 1, newY, V^.W - 2, 1, 0);
  END Reduce;


  PROCEDURE Restore(V: Viewer);

    VAR
      Menu: Display.Frame;
      Main: Display.Frame;
      M: Display.ControlMsg;

  BEGIN  (* PROCEDURE Restore *)
    Menu := V^.dsc;
    Main := V^.dsc^.next;
    Oberon.RemoveMarks(V^.X, V^.Y, V^.W, V^.H);
    Draw(V);
    Menu^.X := (V^.X + 1);
    Menu^.Y := ((V^.Y + V^.H) - 1);
    Menu^.W := (V^.W - 2);
    Menu^.H := 0;
    Main^.X := (V^.X + 1);
    Main^.Y := ((V^.Y + V^.H) - V^.menuH);
    Main^.W := (V^.W - 2);
    Main^.H := 0;
    M.F := NIL;
    M.id := 2;
    M.res := -1;
    Objects.Stamp(M);
    M.dlink := NIL;
    M.x := 0;
    M.y := 0;
    Menu^.handle(Menu, M);
    Main^.handle(Main, M);
    IF (V^.H > (V^.menuH + 1)) THEN
      ModifyFrame(Menu, 1, 0, ((V^.Y + V^.H) - V^.menuH), V^.menuH - 1);
      ModifyFrame(Main, 1, 0, V^.Y + 1, ((V^.H - V^.menuH) - 1));
    ELSE
      ModifyFrame(Menu, 1, 0, V^.Y + 1, V^.H - 2);
    END;  (* IF *)
  END Restore;


  PROCEDURE Shrink(V: Viewer; newH: INTEGER);

  BEGIN  (* PROCEDURE Shrink *)
    Display.ReplConst(LightFrame, V^.X + 1, ((V^.Y + newH) - 1), V^.W - 2, 1, 0);
  END Shrink;


  PROCEDURE Suspend(V: Viewer);

    VAR
      Menu: Display.Frame;
      Main: Display.Frame;

  BEGIN  (* PROCEDURE Suspend *)
    Menu := V^.dsc;
    Main := V^.dsc^.next;
    ModifyFrame(Main, 0, 0, ((V^.Y + V^.H) - V^.menuH), 0);
    ModifyFrame(Menu, 0, 0, ((V^.Y + V^.H) - 1), 0);
  END Suspend;


  PROCEDURE GetName*(V: Viewer; VAR name: ARRAYAE);

    VAR
      M: Objects.AttrMsg;

  BEGIN  (* PROCEDURE GetName *)
    M.id := 1;
    M.name := "Name";
    M.s[0] := 000X;
    M.res := -32768;
    V^.dsc^.handle(V^.dsc, M);
    COPY(M.s, name);
  END GetName;


  PROCEDURE Handle*(V: Objects.Object; VAR M: Objects.ObjMsg);

    VAR
      V1: Viewer;
      Menu: Display.Frame;
      Main: Display.Frame;

  BEGIN  (* PROCEDURE Handle *)
    WITH V: Viewer DO
      Menu := V^.dsc;
      Main := V^.dsc^.next;
      IF (M IS Oberon.InputMsg) THEN
        WITH M: Oberon.InputMsg DO
          IF (M.id = 1) THEN
            IF (M.Y < (V^.Y + 1)) THEN
              Oberon.DrawCursor(Oberon.Mouse, Oberon.Arrow, M.X, M.Y);
            ELSIF (M.Y < ((V^.Y + V^.H) - V^.menuH)) THEN
              Main^.handle(Main, M);
            ELSIF (M.Y < ((V^.Y + V^.H) - ASH(V^.menuH, -2) * 3)) THEN
              Menu^.handle(Menu, M);
            ELSIF (M.Y < ((V^.Y + V^.H) - 1)) THEN
              IF (2 IN M.keys) THEN
                Change(V, M.X, M.Y, M.keys);
              ELSE
                Menu^.handle(Menu, M);
              END;  (* IF *)
            ELSE
              Oberon.DrawCursor(Oberon.Mouse, Oberon.Arrow, M.X, M.Y);
            END;  (* IF *)
          ELSE
            Menu^.handle(Menu, M);
            Main^.handle(Main, M);
          END;  (* IF *)
        END;  (* WITH *)
      ELSIF (M IS Oberon.ControlMsg) THEN
        WITH M: Oberon.ControlMsg DO
          IF (M.id = 2) THEN
            IF (M.X >= V^.X) & (M.X < (V^.X + V^.W)) & (M.Y >= V^.Y) & (M.Y < (V^.Y + V^.H)) THEN
              Oberon.DrawCursor(Oberon.Mouse, Oberon.Arrow, M.X, M.Y);
              Oberon.DrawCursor(Oberon.Pointer, Oberon.Star, M.X, M.Y);
            END;  (* IF *)
          ELSE
            Menu^.handle(Menu, M);
            Main^.handle(Main, M);
          END;  (* IF *)
        END;  (* WITH *)
      ELSIF (M IS Display.LocateMsg) THEN
        WITH M: Display.LocateMsg DO
          IF (M.F = NIL) THEN
            Menu^.handle(Menu, M);
            Main^.handle(Main, M);
          END;  (* IF *)
        END;  (* WITH *)
      ELSIF (M IS Display.ModifyMsg) THEN
        WITH M: Display.ModifyMsg DO
          IF (M.F = V) THEN
            ModifyViewer(V, M.id, M.Y, M.H);
          ELSE
            IF (M.F # Menu) THEN
              Menu^.handle(Menu, M);
            END;  (* IF *)
            IF (M.F # Main) THEN
              Main^.handle(Main, M);
            END;  (* IF *)
          END;  (* IF *)
        END;  (* WITH *)
      ELSIF (M IS Objects.CopyMsg) THEN
        WITH M: Objects.CopyMsg DO
          Copy(V, V1);
          M.obj := V1;
        END;  (* WITH *)
      ELSIF (M IS Display.ControlMsg) THEN
        WITH M: Display.ControlMsg DO
          IF (M.id = 2) THEN
            Restore(V);
          ELSIF (M.id = 1) THEN
            Suspend(V);
          ELSE
            Menu^.handle(Menu, M);
            Main^.handle(Main, M);
          END;  (* IF *)
        END;  (* WITH *)
      ELSE
        Menu^.handle(Menu, M);
        Main^.handle(Main, M);
      END;  (* IF *)
    END;  (* WITH *)
  END Handle;


  PROCEDURE New*(Menu: Display.Frame; Main: Display.Frame; menuH: INTEGER; X: INTEGER; Y: INTEGER): Viewer;

    VAR
      V: Viewer;

  BEGIN  (* PROCEDURE New *)
    NEW(V);
    V^.handle := (Handle);
    V^.dsc := Menu;
    V^.dsc^.next := Main;
    V^.menuH := menuH;
    Viewers.Open(V, X, Y);
    Restore(V);
    RETURN V;
  END New;


BEGIN  (* MODULE MenuViewers *)
  Init();
END MenuViewers.
