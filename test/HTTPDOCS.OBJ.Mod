(***************************************************************************

   Input File:   HTTPDOCS.OBJ
   Date/Time:    Mon Jan 11 18:14:03 2021
   -------------------------------------------------------

   Generated by Slim Binary(tm) Decoder Version 2.00

 ***************************************************************************)

MODULE HTTPDocs;    (* Slim Binary(tm) *)

  IMPORT
    NetSystem, MIME, Texts, Documents, Files, Objects, Input, Display, NetTools, Streams, HyperDocs, Attributes, Links, Oberon, Strings, TextDocs, HTTPDocs0, TextStreams, HTMLDocs;

  CONST
    Client = "HTTPDocs for Oberon (ejz)";
    MaxWorkers = 4;

  TYPE
    ARRAY76 = ARRAY OF CHAR;
    ARRAY95 = ARRAY OF CHAR;
    ARRAY1B1 = ARRAY 64 OF CHAR;
    ARRAY1CB = ARRAY 64 OF CHAR;
    ARRAY1D3 = ARRAY 256 OF CHAR;
    Cookie = POINTER TO CookieDesc;
    CookieDesc = RECORD
      VAR1CF: ARRAY1CB;
      VAR1D1: ARRAY1CB;
      VAR1D7: ARRAY1D3;
      VAR1D9: ARRAY1D3;
      VAR1DB: LONGINT;
      VAR1DD: LONGINT;
      VAR1DF: Cookie;
    END;
    ARRAY1EF = ARRAY 1024 OF CHAR;
    ARRAY20B = ARRAY 64 OF CHAR;
    ARRAY211 = ARRAY 256 OF CHAR;
    ARRAY217 = ARRAY 64 OF CHAR;
    Authorization = POINTER TO AuthorizationDesc;
    AuthorizationDesc = RECORD
      VAR20F: ARRAY20B;
      VAR215: ARRAY211;
      VAR21B: ARRAY217;
      VAR21D: INTEGER;
      VAR21F: Authorization;
    END;
    ARRAY245 = ARRAY 64 OF CHAR;
    ARRAY2D5 = ARRAY OF CHAR;
    ARRAY2FD = ARRAY OF CHAR;
    ARRAY318 = ARRAY OF CHAR;
    ARRAY358 = ARRAY OF CHAR;
    ARRAY395 = ARRAY OF CHAR;
    ARRAY3CC = ARRAY OF CHAR;
    ARRAY44E = ARRAY 32 OF CHAR;
    WorkerDesc = RECORD(HTTPDocs0.WorkerDesc)
      VAR44C: NetSystem.Connection;
      VAR451: ARRAY44E;
      VAR458: Files.Rider;
      VAR45C: MIME.Content;
      VAR45E: BOOLEAN;
    END;
    Worker = POINTER TO WorkerDesc;

  VAR
    noWorkers: INTEGER;
    encTable: ARRAY1B1;
    cookies: Cookie;
    buf: ARRAY1EF;
    authorizations: Authorization;
    W: Texts.Writer;
    EMail: ARRAY245;

  (* Forward PROCEDURE declarations *)

  PROCEDURE^ DoWork(me: Oberon.Task);
  PROCEDURE^ LinkSchemeHandler(L: Objects.Object; VAR M: Objects.ObjMsg);
  PROCEDURE^ TCPAvailable(S: Streams.Stream): LONGINT;
  PROCEDURE^ requestDoc(D: Documents.Document; proxy: HTTPDocs0.Proxy; VAR key: LONGINT; method: ARRAY3CC; main: BOOLEAN; E: HTTPDocs0.Entry; query: Texts.Text);
  PROCEDURE^ AddCookie(VAR host: ARRAY395; VAR path: ARRAY395; VAR value: ARRAY395);
  PROCEDURE^ Connect(VAR C: NetSystem.Connection; proxy: HTTPDocs0.Proxy; main: BOOLEAN; waitR: BOOLEAN; reloc: BOOLEAN; block: BOOLEAN; method: ARRAY358; VAR key: LONGINT; VAR cont: MIME.Content; query: Texts.Text; log: BOOLEAN; VAR useProxy: BOOLEAN): LONGINT;
  PROCEDURE^ EncBase64(VAR src: ARRAY318; VAR dest: ARRAY318);
  PROCEDURE^ FindCookie(root: Cookie; VAR host: ARRAY2FD; VAR path: ARRAY2FD): Cookie;
  PROCEDURE^ GetAuthorization(VAR host: ARRAY2D5; VAR path: ARRAY2D5; port: INTEGER): Authorization;
  PROCEDURE^ InitTables();
  PROCEDURE^ Install(E: HTTPDocs0.Entry);
  PROCEDURE^ NetLen(T: Texts.Text): LONGINT;
  PROCEDURE^ OpenHTTPDoc(D: Documents.Document; key: LONGINT; proxy: HTTPDocs0.Proxy);
  PROCEDURE^ OpenStream(C: NetSystem.Connection): Streams.Stream;
  PROCEDURE^ StartWorker();
  PROCEDURE^ ListCookies*();
  PROCEDURE^ LoadDoc*(D: Documents.Document);
  PROCEDURE^ NewDoc*();
  PROCEDURE^ NewLinkScheme*();
  PROCEDURE^ ReplaceDoc*();
  PROCEDURE^ Request*(C: NetSystem.Connection; method: ARRAY95; VAR key: LONGINT; proxy: BOOLEAN; VAR query: Texts.Text; log: BOOLEAN);
  PROCEDURE^ Response*(VAR C: NetSystem.Connection; key: LONGINT; main: BOOLEAN; VAR cont: MIME.Content; VAR location: ARRAY76; log: BOOLEAN): LONGINT;

  PROCEDURE DoWork(me: Oberon.Task);

    TYPE
      ARRAY1C0F = ARRAY 1024 OF CHAR;

    VAR
      state: INTEGER;
      location: ARRAY1C0F;
      len: LONGINT;
      key: LONGINT;
      e: HTTPDocs0.Entry;
      T: Texts.Text;
      F: Files.File;

  BEGIN  (* PROCEDURE DoWork *)
    WITH me: Worker DO
      IF me^.local THEN
        RETURN;
      END;  (* IF *)
      CASE me^.state OF
      | 0:
        IF (me^.entry^.doc = NIL) THEN
          me^.entry^.doc := HyperDocs.GetCachedDoc(me^.entry^.key);
          IF (me^.entry^.doc = NIL) THEN
            len := Connect(me^.VAR44C, HTTPDocs0.httpProxy, FALSE, FALSE, FALSE, FALSE, "GET", me^.entry^.key, me^.VAR45C, NIL, FALSE, me^.VAR45E);
            IF (me^.VAR44C # NIL) THEN
              me^.state := 1;
              me^.time := (Input.Time() + Input.TimeUnit DIV 20);
            ELSE
              me^.state := 6;
              me^.time := (Input.Time() + ASH(Input.TimeUnit, 1));
            END;  (* IF *)
          END;  (* IF *)
        END;  (* IF *)
        IF (me^.entry^.doc # NIL) & (me^.entry^.text^.len > me^.entry^.pos) THEN
          me^.state := 5;
          HTTPDocs0.InsertDoc(me);
        END;  (* IF *)
      | 1:
        state := NetSystem.State(me^.VAR44C);
        IF (state IN {2,4}) THEN
          T := NIL;
          Request(me^.VAR44C, "GET", me^.entry^.key, me^.VAR45E, T, FALSE);
          me^.state := 2;
        ELSIF (state = 5) THEN
          me^.time := (Input.Time() + Input.TimeUnit DIV 20);
        ELSE
          me^.state := 6;
          me^.time := (Input.Time() + ASH(Input.TimeUnit, 1));
        END;  (* IF *)
      | 2:
        len := NetSystem.Available(me^.VAR44C);
        IF (len > 0) THEN
          len := Response(me^.VAR44C, me^.entry^.key, FALSE, me^.VAR45C, location, FALSE);
          IF (me^.VAR44C # NIL) THEN
            IF (location[0] # 000X) THEN
              key := HyperDocs.BuildKey(NIL, location);
              IF (key # me^.entry^.key) THEN
                me^.entry^.key := key;
                me^.state := 6;
              END;  (* IF *)
            END;  (* IF *)
            IF (me^.state = 2) THEN
              IF ~me^.VAR45C^.typ^.support THEN
                me^.state := 5;
              ELSIF (me^.VAR45C^.typ^.typ = "text") THEN
                me^.state := 5;
              ELSE
                MIME.MakeTempName(me^.VAR45C^.typ, me^.VAR451);
                F := Files.New(me^.VAR451);
                Files.Set(me^.VAR458, F, 0);
                me^.state := 3;
              END;  (* IF *)
            END;  (* IF *)
          ELSE
            me^.state := 5;
          END;  (* IF *)
        ELSE
          me^.time := (Input.Time() + Input.TimeUnit DIV 20);
        END;  (* IF *)
      | 3:
        len := NetSystem.Available(me^.VAR44C);
        IF (len > 0) THEN
          IF (len > 1024) THEN
            len := 1024;
          END;  (* IF *)
          NetSystem.ReadBytes(me^.VAR44C, 0, len, buf);
          Files.WriteBytes(me^.VAR458, buf, len);
        ELSIF ~NetTools.Connected(me^.VAR44C, 2) THEN
          me^.state := 4;
        ELSE
          INC(me^.time, Input.TimeUnit DIV 50);
        END;  (* IF *)
      | 4:
        Files.Register(Files.Base(me^.VAR458));
        me^.state := 5;
        me^.entry^.doc := Documents.Open(me^.VAR451);
        IF (me^.entry^.doc # NIL) & (me^.entry^.doc^.dsc # NIL) THEN
          HyperDocs.CacheDoc(me^.entry^.key, me^.entry^.doc);
          me^.state := 0;
        END;  (* IF *)
      | 5, 6:
        IF (me^.VAR44C # NIL) THEN
          NetTools.Disconnect(me^.VAR44C);
          me^.VAR44C := NIL;
        END;  (* IF *)
        Oberon.Remove(me^.entry^.working);
        IF (noWorkers > 0) THEN
          DEC(noWorkers, 1);
        END;  (* IF *)
        IF (me # me^.entry^.working) THEN
          Oberon.Remove(me);
        END;  (* IF *)
        me^.entry^.working := NIL;
        IF (me^.state = 5) THEN
          e := HTTPDocs0.entries;
          WHILE (e # NIL) & (e^.next # me^.entry) DO
            e := e^.next;
          END;  (* WHILE *)
          IF (e # NIL) THEN
            e^.next := me^.entry^.next;
          ELSE
            HTTPDocs0.entries := me^.entry^.next;
          END;  (* IF *)
        END;  (* IF *)
        Oberon.Collect();
        StartWorker();
      END;  (* CASE *)
    END;  (* WITH *)
  END DoWork;


  PROCEDURE LinkSchemeHandler(L: Objects.Object; VAR M: Objects.ObjMsg);

    TYPE
      ARRAY1A20 = ARRAY 256 OF CHAR;
      ARRAY1A29 = ARRAY 1024 OF CHAR;
      ARRAY1A32 = ARRAY 64 OF CHAR;
      ARRAY1A3C = ARRAY 64 OF CHAR;

    VAR
      useProxy: BOOLEAN;
      status: LONGINT;
      proxy: HTTPDocs0.Proxy;
      port: INTEGER;
      path: ARRAY1A20;
      link: ARRAY1A29;
      label: ARRAY1A32;
      host: ARRAY1A3C;
      cont: MIME.Content;
      T: Texts.Text;
      C: NetSystem.Connection;

  BEGIN  (* PROCEDURE LinkSchemeHandler *)
    WITH L: HyperDocs.LinkScheme DO
      IF (M IS HyperDocs.RegisterLinkMsg) THEN
        WITH M: HyperDocs.RegisterLinkMsg DO
          IF ((M.base = NIL) OR HyperDocs.CheckPrefix(M.link)) THEN
            M.key := HTTPDocs0.SplitHTTPAdr(M.link, host, path, label, port);
          ELSIF (M.base^.prefix = "http") THEN
            link := "http://";
            Strings.Append(link, M.base^.host);
            IF (M.base^.port # 80) THEN
              Strings.AppendCh(link, ":");
              Strings.IntToStr(M.base^.port, label);
              Strings.Append(link, label);
            END;  (* IF *)
            HyperDocs.Path(M.base, link, M.link);
            M.key := HyperDocs.RegisterLink(link);
          ELSE
            HyperDocs.LinkSchemeHandler(L, M);
          END;  (* IF *)
          IF (M.key # -1) THEN
            M.res := 0;
          END;  (* IF *)
        END;  (* WITH *)
      ELSIF (M IS HyperDocs.InfoMsg) THEN
        WITH M: HyperDocs.InfoMsg DO
          status := Connect(C, HTTPDocs0.httpProxy, TRUE, FALSE, FALSE, TRUE, "HEAD", M.key, cont, NIL, TRUE, useProxy);
          IF (C # NIL) THEN
            T := NIL;
            Request(C, "HEAD", M.key, useProxy, T, TRUE);
            status := Response(C, M.key, TRUE, cont, path, TRUE);
            M.contType := cont^.typ;
            M.size := cont^.len;
            NetTools.Disconnect(C);
            M.res := 0;
          ELSE
            HyperDocs.LinkSchemeHandler(L, M);
          END;  (* IF *)
        END;  (* WITH *)
      ELSIF (M IS HyperDocs.FetchMsg) THEN
        WITH M: HyperDocs.FetchMsg DO
          IF (M.key # -1) THEN
            status := Connect(C, HTTPDocs0.httpProxy, TRUE, TRUE, TRUE, TRUE, "GET", M.key, cont, NIL, TRUE, useProxy);
            IF (C # NIL) THEN
              IF (status >= 200) & (status < 400) THEN
                M.res := 0;
                Texts.WriteString(W, " downloading ");
                Texts.Append(Oberon.Log, W.buf);
                NetTools.ReadData(C, M.R, 2147483647);
                Texts.WriteString(W, " done");
                Texts.WriteLn(W);
              END;  (* IF *)
              NetTools.Disconnect(C);
            END;  (* IF *)
            Texts.Append(Oberon.Log, W.buf);
          ELSE
            M.res := 0;
          END;  (* IF *)
        END;  (* WITH *)
      ELSIF (M IS NetTools.ProxyMsg) THEN
        WITH M: NetTools.ProxyMsg DO
          NEW(proxy);
          COPY(M.host, proxy^.host);
          proxy^.port := M.port;
          OpenHTTPDoc(M.D, M.key, proxy);
        END;  (* WITH *)
      ELSIF (M IS Objects.AttrMsg) THEN
        WITH M: Objects.AttrMsg DO
          IF (M.id = 1) & (M.name = "Gen") THEN
            M.class := 2;
            M.s := "HTTPDocs.NewLinkScheme";
            M.res := 0;
          ELSE
            HyperDocs.LinkSchemeHandler(L, M);
          END;  (* IF *)
        END;  (* WITH *)
      ELSE
        HyperDocs.LinkSchemeHandler(L, M);
      END;  (* IF *)
    END;  (* WITH *)
  END LinkSchemeHandler;


  PROCEDURE TCPAvailable(S: Streams.Stream): LONGINT;

  BEGIN  (* PROCEDURE TCPAvailable *)
    HTTPDocs0.Wait();
    RETURN NetTools.TCPAvailable(S);
  END TCPAvailable;


  PROCEDURE requestDoc(D: Documents.Document; proxy: HTTPDocs0.Proxy; VAR key: LONGINT; method: ARRAY3CC; main: BOOLEAN; E: HTTPDocs0.Entry; query: Texts.Text);

    TYPE
      ARRAY1EFE = ARRAY 64 OF CHAR;

    VAR
      useProxy: BOOLEAN;
      temp: ARRAY1EFE;
      status: LONGINT;
      origKey: LONGINT;
      i: LONGINT;
      getQuery: BOOLEAN;
      cont: MIME.Content;
      T: Texts.Text;
      S: Streams.Stream;
      R: Files.Rider;
      P: HTMLDocs.Page;
      M: Objects.CopyMsg;
      F: Files.File;
      D2: Documents.Document;
      C: NetSystem.Connection;

  BEGIN  (* PROCEDURE requestDoc *)
    IF (E # NIL) THEN
      E^.key := key;
      Install(E);
    ELSE
      D2 := HyperDocs.GetCachedDoc(key);
      IF (D2 # NIL) & (D2^.dsc # NIL) THEN
        D^ := D2^;
        D^.lib := NIL;
        D^.ref := -1;
        RETURN;
      ELSE
        T := HyperDocs.GetCachedText(key);
        IF (T # NIL) THEN
          S := TextStreams.OpenReader(T, 0);
          S^.mode := 2;
          HTMLDocs.Parse(D, key, S, TRUE, FALSE, FALSE);
          Attributes.SetInt(D, "DocURL", key);
          HyperDocs.RetrieveLink(key, D^.name);
          RETURN;
        ELSE
          P := HTMLDocs.pages;
          WHILE (P # NIL) & (P^.docKey # key) DO
            P := P^.next;
          END;  (* WHILE *)
          IF (P # NIL) THEN
            Objects.Stamp(M);
            M.dlink := NIL;
            M.obj := NIL;
            M.id := 0;
            Documents.Copy(M, P^.D, D);
            D^.lib := NIL;
            D^.ref := -1;
            Attributes.SetInt(D, "DocURL", key);
            HyperDocs.RetrieveLink(key, D^.name);
            RETURN;
          END;  (* IF *)
        END;  (* IF *)
      END;  (* IF *)
      P := NIL;
      origKey := key;
      status := Connect(C, proxy, main, TRUE, TRUE, TRUE, method, key, cont, query, TRUE, useProxy);
      IF (C # NIL) THEN
        IF (status = 204) THEN
          RETURN;
        ELSIF (status = 401) THEN
          TextDocs.InitDoc(D);
          D^.W := HyperDocs.docW;
          D^.H := HyperDocs.docH;
          NEW(T);
          Texts.Open(T, "Authorization.html");
          S := TextStreams.OpenReader(T, 0);
          S^.mode := 0;
          HTMLDocs.Parse(D, key, S, TRUE, FALSE, FALSE);
        ELSIF cont^.typ^.support THEN
          IF (cont^.typ^.typ = "text") THEN
            TextDocs.InitDoc(D);
            D^.W := HyperDocs.docW;
            D^.H := HyperDocs.docH;
            S := OpenStream(C);
            IF (cont^.typ^.subTyp = "html") THEN
              HyperDocs.RetrieveLink(key, buf);
              getQuery := FALSE;
              i := 0;
              WHILE (buf[i] # 000X) DO
                getQuery := (getQuery OR (buf[i] = "?"));
                INC(i, 1);
              END;  (* WHILE *)
              S^.mode := 2;
              HTMLDocs.Parse(D, key, S, TRUE, (query = NIL) & ~getQuery, FALSE);
              C := NIL;
              P := HTMLDocs.pages;
            ELSE
              NEW(T);
              Texts.Open(T, "");
              cont^.len := 2147483647;
              MIME.ReadText(S, W, cont, FALSE);
              Texts.Append(T, W.buf);
              Links.SetLink(D^.dsc, "Model", T);
              HyperDocs.RetrieveLink(origKey, D^.name);
            END;  (* IF *)
          ELSE
            MIME.MakeTempName(cont^.typ, temp);
            F := Files.New(temp);
            Files.Set(R, F, 0);
            NetTools.ReadData(C, R, 2147483647);
            Files.Register(F);
            D^.name[0] := 000X;
            D^.dsc := NIL;
            D2 := Documents.Open(temp);
            IF (D2 # NIL) & (D2^.dsc # NIL) THEN
              D^ := D2^;
              D^.lib := NIL;
              D^.ref := -1;
              HyperDocs.RetrieveLink(origKey, D^.name);
            END;  (* IF *)
          END;  (* IF *)
        ELSE
          D^.name[0] := 000X;
          D^.dsc := NIL;
        END;  (* IF *)
        NetTools.Disconnect(C);
        IF (D # NIL) & (D^.dsc # NIL) THEN
          IF (status >= 200) & (status < 400) & (cont^.typ^.typ = "text") & (cont^.typ^.subTyp = "html") THEN
            Attributes.SetInt(D, "DocURL", origKey);
            HyperDocs.RetrieveLink(key, D^.name);
            IF (query # NIL) THEN
              HyperDocs.TempDocName("http://Temp.Query", D^.name, key);
              IF (P # NIL) THEN
                P^.docKey := key;
                P^.cacheSource := TRUE;
              END;  (* IF *)
              IF (HyperDocs.context # NIL) & (HyperDocs.context^.new # NIL) THEN
                HyperDocs.context^.new^.key := key;
              END;  (* IF *)
            ELSE
              Attributes.GetString(D, "Type", temp);
              IF (temp # "HTML") & ~main THEN
                HyperDocs.CacheDoc(origKey, D);
              END;  (* IF *)
            END;  (* IF *)
          END;  (* IF *)
        END;  (* IF *)
      END;  (* IF *)
    END;  (* IF *)
  END requestDoc;


  PROCEDURE AddCookie(VAR host: ARRAY395; VAR path: ARRAY395; VAR value: ARRAY395);

    TYPE
      ARRAY1181 = ARRAY 64 OF CHAR;
      ARRAY11AB = ARRAY OF CHAR;

    VAR
      p: BOOLEAN;
      name: ARRAY1181;
      i: LONGINT;
      e: BOOLEAN;
      d: BOOLEAN;
      c: Cookie;
      C: Cookie;

    (* Forward PROCEDURE declarations *)

    PROCEDURE^ GetName();
    PROCEDURE^ GetValue(VAR val: ARRAY11AB);
    PROCEDURE^ Skip();

    PROCEDURE GetName();

      VAR
        j: LONGINT;

    BEGIN  (* PROCEDURE GetName *)
      Skip();
      j := 0;
      WHILE (value[i] > " ") & (value[i] # "=") & (value[i] # 000X) DO
        name[j] := Strings.UpperCh(value[i]);
        INC(j, 1);
        INC(i, 1);
      END;  (* WHILE *)
      name[j] := 000X;
      Skip();
      IF (value[i] = "=") THEN
        INC(i, 1);
      END;  (* IF *)
      Skip();
    END GetName;


    PROCEDURE GetValue(VAR val: ARRAY11AB);

      VAR
        j: LONGINT;

    BEGIN  (* PROCEDURE GetValue *)
      Skip();
      j := 0;
      WHILE (value[i] # ";") & (value[i] # 000X) DO
        val[j] := value[i];
        INC(j, 1);
        INC(i, 1);
      END;  (* WHILE *)
      val[j] := 000X;
      Skip();
      IF (value[i] = ";") THEN
        INC(i, 1);
      END;  (* IF *)
      Skip();
    END GetValue;


    PROCEDURE Skip();

    BEGIN  (* PROCEDURE Skip *)
      WHILE (value[i] <= " ") & (value[i] # 000X) DO
        INC(i, 1);
      END;  (* WHILE *)
    END Skip;


  BEGIN  (* PROCEDURE AddCookie *)
    i := 0;
    WHILE (value[i] # ":") & (value[i] # 000X) DO
      INC(i, 1);
    END;  (* WHILE *)
    IF (value[i] = ":") THEN
      p := FALSE;
      e := FALSE;
      d := FALSE;
      C := NIL;
      INC(i, 1);
      WHILE (value[i] # 000X) DO
        GetName();
        IF (value[i] # 000X) THEN
          IF (C = NIL) THEN
            NEW(C);
            C^.VAR1CF[0] := 000X;
          END;  (* IF *)
          IF (name = "PATH") THEN
            GetValue(C^.VAR1D9);
            p := TRUE;
          ELSIF (name = "EXPIRES") THEN
            GetValue(name);
            e := TRUE;
          ELSIF (name = "DOMAIN") THEN
            GetValue(C^.VAR1D1);
            d := TRUE;
          ELSE
            COPY(name, C^.VAR1CF);
            GetValue(C^.VAR1D7);
          END;  (* IF *)
        END;  (* IF *)
      END;  (* WHILE *)
      IF (C # NIL) & (C^.VAR1CF[0] # 000X) THEN
        IF ~p THEN
          COPY(path, C^.VAR1D9);
        END;  (* IF *)
        IF ~d THEN
          COPY(host, C^.VAR1D1);
        END;  (* IF *)
        IF ~e THEN
        END;  (* IF *)
        c := cookies;
        WHILE (c # NIL) & ((c^.VAR1CF # C^.VAR1CF) OR (c^.VAR1D9 # C^.VAR1D9)) DO
          c := c^.VAR1DF;
        END;  (* WHILE *)
        IF (c # NIL) THEN
          COPY(C^.VAR1CF, c^.VAR1CF);
          COPY(C^.VAR1D1, c^.VAR1D1);
          COPY(C^.VAR1D7, c^.VAR1D7);
          c^.VAR1DB := C^.VAR1DB;
          c^.VAR1DD := C^.VAR1DD;
        ELSE
          C^.VAR1DF := cookies;
          cookies := C;
        END;  (* IF *)
      END;  (* IF *)
    END;  (* IF *)
  END AddCookie;


  PROCEDURE Connect(VAR C: NetSystem.Connection; proxy: HTTPDocs0.Proxy; main: BOOLEAN; waitR: BOOLEAN; reloc: BOOLEAN; block: BOOLEAN; method: ARRAY358; VAR key: LONGINT; VAR cont: MIME.Content; query: Texts.Text; log: BOOLEAN; VAR useProxy: BOOLEAN): LONGINT;

    TYPE
      ARRAY18E9 = ARRAY 1024 OF CHAR;
      ARRAY18FC = ARRAY 64 OF CHAR;

    VAR
      status: LONGINT;
      port: INTEGER;
      location: ARRAY18E9;
      key2: LONGINT;
      host: ARRAY18FC;
      base: HyperDocs.DefURL;

  BEGIN  (* PROCEDURE Connect *)
    status := 0;
    HyperDocs.RetrieveLink(key, location);
    NetTools.SplitHostPort(location, host, port);
    useProxy := NetTools.UseProxy(host) & (proxy # NIL);
    IF ~useProxy THEN
      IF (port <= 0) THEN
        port := 80;
      END;  (* IF *)
      IF block THEN
        IF ~NetTools.Connect(C, port, host, log) THEN
          C := NIL;
        END;  (* IF *)
      ELSE
        IF ~NetTools.AsyncConnect(C, port, host, log) THEN
          C := NIL;
        END;  (* IF *)
      END;  (* IF *)
    ELSE
      IF block THEN
        IF ~NetTools.Connect(C, proxy^.port, proxy^.host, FALSE) THEN
          C := NIL;
        END;  (* IF *)
      ELSE
        IF ~NetTools.AsyncConnect(C, proxy^.port, proxy^.host, FALSE) THEN
          C := NIL;
        END;  (* IF *)
      END;  (* IF *)
    END;  (* IF *)
    IF (C # NIL) THEN
      IF log THEN
        Texts.Write(W, " ");
        Texts.Append(Oberon.Log, W.buf);
      END;  (* IF *)
      IF waitR THEN
        Request(C, method, key, useProxy, query, log);
        status := Response(C, key, main, cont, location, log);
        IF (C = NIL) THEN
          RETURN status;
        END;  (* IF *)
        IF reloc & (location[0] # 000X) THEN
          NEW(base);
          base^.key := key;
          base^.prefix := "http";
          HyperDocs.RetrieveLink(base^.key, buf);
          key2 := HTTPDocs0.SplitHTTPAdr(buf, base^.host, base^.path, host, base^.port);
          key2 := HyperDocs.BuildKey(base, location);
          IF (key # key2) THEN
            IF log THEN
              Texts.WriteString(W, "relocating ");
              Texts.Append(Oberon.Log, W.buf);
            END;  (* IF *)
            NetTools.Disconnect(C);
            key := key2;
            IF (method = "GET") THEN
              query := NIL;
            END;  (* IF *)
            status := Connect(C, proxy, main, waitR, FALSE, block, method, key, cont, query, log, useProxy);
          END;  (* IF *)
        END;  (* IF *)
      END;  (* IF *)
    END;  (* IF *)
    IF log THEN
      Texts.Append(Oberon.Log, W.buf);
    END;  (* IF *)
    RETURN status;
  END Connect;


  PROCEDURE EncBase64(VAR src: ARRAY318; VAR dest: ARRAY318);

    TYPE
      ARRAY1052 = ARRAY 3 OF CHAR;

    VAR
      s: LONGINT;
      j: LONGINT;
      i: LONGINT;
      d: LONGINT;
      chars: ARRAY1052;
      c2: LONGINT;
      c1: LONGINT;
      c0: LONGINT;
      c: LONGINT;
      @for: LONGINT;


    PROCEDURE OutCode();

    BEGIN  (* PROCEDURE OutCode *)
      c0 := ORD(chars[0]);
      c := ASH(c0, -2);
      dest[d] := encTable[c];
      INC(d, 1);
      c0 := (c0 - ASH(c, 2));
      c1 := ORD(chars[1]);
      c := (ASH(c0, 4) + ASH(c1, -4));
      dest[d] := encTable[c];
      INC(d, 1);
      c1 := c1 MOD 16;
      c2 := ORD(chars[2]);
      c := (ASH(c1, 2) + ASH(c2, -6));
      dest[d] := encTable[c];
      INC(d, 1);
      c2 := c2 MOD 64;
      dest[d] := encTable[c2];
      INC(d, 1);
    END OutCode;


  BEGIN  (* PROCEDURE EncBase64 *)
    s := 1;
    d := 0;
    chars[0] := src[0];
    i := 1;
    WHILE (src[s] # 000X) DO
      IF (i >= 3) THEN
        OutCode();
        i := 0;
      END;  (* IF *)
      chars[i] := src[s];
      INC(i, 1);
      INC(s, 1);
    END;  (* WHILE *)
    IF (i > 0) THEN
      j := i;
      WHILE (i < 3) DO
        chars[i] := 000X;
        INC(i, 1);
      END;  (* WHILE *)
      OutCode();
      IF (j < 3) THEN
        j := (3 - j);
        d := (d - j);
        @for := j;
        i := 1;
        WHILE (i <= @for) DO
          dest[d] := "=";
          INC(d, 1);
          INC(i, 1);
        END;  (* WHILE *)
      END;  (* IF *)
    END;  (* IF *)
    dest[d] := 000X;
  END EncBase64;


  PROCEDURE FindCookie(root: Cookie; VAR host: ARRAY2FD; VAR path: ARRAY2FD): Cookie;

    VAR
      c: Cookie;

  BEGIN  (* PROCEDURE FindCookie *)
    c := root;
    WHILE (c # NIL) & ~Strings.Prefix(c^.VAR1D9, path) DO
      c := c^.VAR1DF;
    END;  (* WHILE *)
    RETURN c;
  END FindCookie;


  PROCEDURE GetAuthorization(VAR host: ARRAY2D5; VAR path: ARRAY2D5; port: INTEGER): Authorization;

    VAR
      aut: Authorization;

  BEGIN  (* PROCEDURE GetAuthorization *)
    aut := authorizations;
    WHILE (aut # NIL) & (aut^.VAR21D # port) & (aut^.VAR20F # host) & (aut^.VAR215 # path) DO
      aut := aut^.VAR21F;
    END;  (* WHILE *)
    RETURN aut;
  END GetAuthorization;


  PROCEDURE InitTables();

    VAR
      max: INTEGER;
      i: INTEGER;
      @for: INTEGER;

  BEGIN  (* PROCEDURE InitTables *)
    max := 25;
    @for := max;
    i := 0;
    WHILE (i <= @for) DO
      encTable[i] := CHR((i + 65));
      INC(i, 1);
    END;  (* WHILE *)
    INC(max, 1);
    @for := ((max + 122) - 97);
    i := max;
    WHILE (i <= @for) DO
      encTable[i] := CHR(((i - max) + 97));
      INC(i, 1);
    END;  (* WHILE *)
    max := (((max + 122) - 97) + 1);
    @for := ((max + 57) - 48);
    i := max;
    WHILE (i <= @for) DO
      encTable[i] := CHR(((i - max) + 48));
      INC(i, 1);
    END;  (* WHILE *)
    encTable[62] := "+";
    encTable[63] := "/";
  END InitTables;


  PROCEDURE Install(E: HTTPDocs0.Entry);

    VAR
      pe: HTTPDocs0.Entry;
      e: HTTPDocs0.Entry;

  BEGIN  (* PROCEDURE Install *)
    E^.working := NIL;
    E^.same := NIL;
    E^.doc := NIL;
    e := HTTPDocs0.entries;
    WHILE (e # NIL) & (e^.key # E^.key) DO
      e := e^.next;
    END;  (* WHILE *)
    IF (e # NIL) THEN
      E^.next := NIL;
      IF (e^.text = E^.text) & (e^.pos = E^.pos) THEN
        RETURN;
      END;  (* IF *)
      WHILE (e^.same # NIL) DO
        e := e^.same;
        IF (e^.text = E^.text) & (e^.pos = E^.pos) THEN
          RETURN;
        END;  (* IF *)
      END;  (* WHILE *)
      e^.same := E;
    ELSE
      pe := NIL;
      e := HTTPDocs0.entries;
      WHILE (e # NIL) & (e^.basekey = E^.basekey) DO
        pe := e;
        e := e^.next;
      END;  (* WHILE *)
      IF (pe # NIL) THEN
        E^.next := pe^.next;
        pe^.next := E;
      ELSE
        E^.next := HTTPDocs0.entries;
        HTTPDocs0.entries := E;
      END;  (* IF *)
      IF (noWorkers < 4) THEN
        StartWorker();
      END;  (* IF *)
    END;  (* IF *)
  END Install;


  PROCEDURE NetLen(T: Texts.Text): LONGINT;

    VAR
      len: LONGINT;
      ch: CHAR;
      R: Texts.Reader;

  BEGIN  (* PROCEDURE NetLen *)
    len := 0;
    Texts.OpenReader(R, T, 0);
    Texts.Read(R, ch);
    WHILE ~R.eot DO
      IF (ch = 00DX) THEN
        INC(len, 1);
      END;  (* IF *)
      INC(len, 1);
      Texts.Read(R, ch);
    END;  (* WHILE *)
    RETURN len;
  END NetLen;


  PROCEDURE OpenHTTPDoc(D: Documents.Document; key: LONGINT; proxy: HTTPDocs0.Proxy);

    TYPE
      ARRAY2194 = ARRAY 8 OF CHAR;

    VAR
      type: ARRAY2194;

  BEGIN  (* PROCEDURE OpenHTTPDoc *)
    IF (HyperDocs.context # NIL) THEN
      HTTPDocs0.curNode := HyperDocs.context^.new;
      IF (HyperDocs.context IS HTTPDocs0.Context) THEN
        HTTPDocs0.RequestDoc(D, proxy, key, HyperDocs.context(HTTPDocs0.Context)^.method, TRUE, NIL, HyperDocs.context(HTTPDocs0.Context)^.query);
      ELSE
        HTTPDocs0.RequestDoc(D, proxy, key, "GET", TRUE, NIL, NIL);
      END;  (* IF *)
    ELSE
      HyperDocs.Remember(key, NIL, HTTPDocs0.curNode);
      HTTPDocs0.RequestDoc(D, proxy, key, "GET", TRUE, NIL, NIL);
    END;  (* IF *)
    IF (D # NIL) & (D^.dsc # NIL) THEN
      Attributes.GetString(D, "Type", type);
      IF (type = "HTML") THEN
        IF (HyperDocs.context = NIL) THEN
          HyperDocs.LinkNodeToDoc(D, HTTPDocs0.curNode);
        ELSE
          HyperDocs.context^.history := TRUE;
        END;  (* IF *)
      ELSIF (HyperDocs.context # NIL) THEN
        HyperDocs.context^.history := FALSE;
        HyperDocs.context^.replace := FALSE;
      END;  (* IF *)
    END;  (* IF *)
  END OpenHTTPDoc;


  PROCEDURE OpenStream(C: NetSystem.Connection): Streams.Stream;

    VAR
      S: Streams.Stream;

  BEGIN  (* PROCEDURE OpenStream *)
    S := NetTools.OpenStream(C);
    S^.Available := (TCPAvailable);
    RETURN S;
  END OpenStream;


  PROCEDURE StartWorker();

    VAR
      W: Worker;
      E: HTTPDocs0.Entry;

  BEGIN  (* PROCEDURE StartWorker *)
    E := HTTPDocs0.entries;
    WHILE (E # NIL) & (E^.working # NIL) DO
      E := E^.next;
    END;  (* WHILE *)
    IF (E # NIL) THEN
      INC(noWorkers, 1);
      NEW(W);
      E^.working := W;
      W^.local := FALSE;
      W^.VAR44C := NIL;
      W^.state := 0;
      W^.VAR451[0] := 000X;
      Files.Set(W^.VAR458, NIL, 0);
      W^.entry := E;
      W^.safe := FALSE;
      W^.time := (Input.Time() + 1);
      W^.handle := (DoWork);
      Oberon.Install(W);
    END;  (* IF *)
  END StartWorker;


  PROCEDURE ListCookies*();

    VAR
      c: Cookie;

  BEGIN  (* PROCEDURE ListCookies *)
    c := cookies;
    WHILE (c # NIL) DO
      Texts.WriteString(W, c^.VAR1CF);
      Texts.Write(W, "=");
      Texts.WriteString(W, c^.VAR1D7);
      Texts.Write(W, ";");
      Texts.WriteString(W, "path=");
      Texts.WriteString(W, c^.VAR1D9);
      Texts.Write(W, ";");
      Texts.WriteString(W, "expires=");
      Texts.WriteDate(W, c^.VAR1DD, c^.VAR1DB);
      Texts.Write(W, ";");
      Texts.WriteString(W, "domain=");
      Texts.WriteString(W, c^.VAR1D1);
      Texts.WriteLn(W);
      c := c^.VAR1DF;
    END;  (* WHILE *)
    Texts.Append(Oberon.Log, W.buf);
  END ListCookies;


  PROCEDURE LoadDoc*(D: Documents.Document);

    VAR
      key: LONGINT;

  BEGIN  (* PROCEDURE LoadDoc *)
    key := HyperDocs.BuildKey(NIL, D^.name);
    IF (key # -1) THEN
      OpenHTTPDoc(D, key, HTTPDocs0.httpProxy);
    END;  (* IF *)
  END LoadDoc;


  PROCEDURE NewDoc*();

    VAR
      D: Documents.Document;

  BEGIN  (* PROCEDURE NewDoc *)
    NEW(D);
    D^.W := HyperDocs.docW;
    D^.H := HyperDocs.docH;
    D^.Load := (LoadDoc);
    Objects.NewObj := D;
  END NewDoc;


  PROCEDURE NewLinkScheme*();

    VAR
      L: HyperDocs.LinkScheme;

  BEGIN  (* PROCEDURE NewLinkScheme *)
    NEW(L);
    L^.handle := (LinkSchemeHandler);
    L^.usePath := TRUE;
    Objects.NewObj := L;
  END NewLinkScheme;


  PROCEDURE ReplaceDoc*();

  BEGIN  (* PROCEDURE ReplaceDoc *)
    HyperDocs.FollowLink();
  END ReplaceDoc;


  PROCEDURE Request*(C: NetSystem.Connection; method: ARRAY95; VAR key: LONGINT; proxy: BOOLEAN; VAR query: Texts.Text; log: BOOLEAN);

    TYPE
      ARRAY13B1 = ARRAY 12 OF CHAR;
      ARRAY13BD = ARRAY 256 OF CHAR;
      ARRAY13C6 = ARRAY 64 OF CHAR;
      ARRAY13D6 = ARRAY 64 OF CHAR;

    VAR
      str: ARRAY13B1;
      port: INTEGER;
      path: ARRAY13BD;
      label: ARRAY13C6;
      j: LONGINT;
      i: LONGINT;
      host: ARRAY13D6;
      cookie: Cookie;
      ch: CHAR;
      aut: Authorization;
      R: Texts.Reader;

  BEGIN  (* PROCEDURE Request *)
    aut := NIL;
    IF log & (method # "GET") THEN
      Texts.WriteString(W, method);
      Texts.Write(W, " ");
    END;  (* IF *)
    NetTools.SendString(C, method);
    NetSystem.Write(C, " ");
    HyperDocs.RetrieveLink(key, buf);
    IF (~proxy OR Strings.CAPPrefix("http:", buf)) THEN
      key := HTTPDocs0.SplitHTTPAdr(buf, host, path, label, port);
      IF log THEN
        Texts.Append(Oberon.Log, W.buf);
      END;  (* IF *)
      j := -1;
      i := 0;
      WHILE (path[i] # 000X) & (j < 0) DO
        IF (path[i] = "?") THEN
          j := i;
        END;  (* IF *)
        INC(i, 1);
      END;  (* WHILE *)
      IF (j > 0) THEN
        path[j] := 000X;
        IF (query = NIL) THEN
          INC(j, 1);
          WHILE (path[j] # 000X) DO
            Texts.Write(W, path[j]);
            INC(j, 1);
          END;  (* WHILE *)
          NEW(query);
          Texts.Open(query, "");
          Texts.Append(query, W.buf);
        END;  (* IF *)
      END;  (* IF *)
      IF proxy THEN
        buf := "http://";
        Strings.Append(buf, host);
        Strings.AppendCh(buf, ":");
        Strings.IntToStr(port, str);
        Strings.Append(buf, str);
        IF log THEN
          Texts.WriteString(W, host);
        END;  (* IF *)
        NetTools.SendString(C, buf);
      END;  (* IF *)
      aut := GetAuthorization(host, path, port);
      IF (aut = NIL) & (HyperDocs.context # NIL) & (HyperDocs.context IS HTTPDocs0.Context) & (HyperDocs.context(HTTPDocs0.Context)^.user[0] # 000X) THEN
        NEW(aut);
        COPY(host, aut^.VAR20F);
        aut^.VAR21D := port;
        COPY(path, aut^.VAR215);
        COPY(HyperDocs.context(HTTPDocs0.Context)^.user, label);
        Strings.AppendCh(label, ":");
        Strings.Append(label, HyperDocs.context(HTTPDocs0.Context)^.passwd);
        EncBase64(label, aut^.VAR21B);
        HyperDocs.context(HTTPDocs0.Context)^.user[0] := 000X;
        aut^.VAR21F := authorizations;
        authorizations := aut;
      END;  (* IF *)
      COPY(path, buf);
      HyperDocs.ESC(buf, 000X);
      IF log THEN
        Texts.WriteString(W, buf);
      END;  (* IF *)
      NetTools.SendString(C, buf);
      IF (query # NIL) & (method = "GET") THEN
        Strings.AppendCh(path, "?");
        i := 0;
        WHILE (path[i] # 000X) DO
          INC(i, 1);
        END;  (* WHILE *)
        Texts.OpenReader(R, query, 0);
        Texts.Read(R, ch);
        WHILE ~R.eot DO
          path[i] := ch;
          INC(i, 1);
          Texts.Read(R, ch);
        END;  (* WHILE *)
        path[i] := 000X;
        key := HTTPDocs0.RegisterHTTPAdr(host, path, label, port);
      END;  (* IF *)
    ELSE
      IF log THEN
        Texts.WriteString(W, buf);
      END;  (* IF *)
      NetTools.SendString(C, buf);
    END;  (* IF *)
    IF (method = "GET") & (query # NIL) THEN
      NetSystem.Write(C, "?");
      Texts.OpenReader(R, query, 0);
      Texts.Read(R, ch);
      WHILE ~R.eot DO
        NetSystem.Write(C, ch);
        Texts.Read(R, ch);
      END;  (* WHILE *)
    END;  (* IF *)
    IF log THEN
      Texts.Append(Oberon.Log, W.buf);
    END;  (* IF *)
    NetSystem.WriteString(C, " HTTP/1.0");
    NetTools.SendString(C, "Host: ");
    NetSystem.WriteString(C, host);
    IF NetTools.QueryString("EMail", EMail) THEN
      NetTools.SendString(C, "From: ");
      NetSystem.WriteString(C, EMail);
    END;  (* IF *)
    NetTools.SendString(C, "Referer: ");
    IF (HyperDocs.context # NIL) & (HyperDocs.context^.old # NIL) THEN
      HyperDocs.RetrieveLink(HyperDocs.context^.old^.key, buf);
      NetSystem.WriteString(C, buf);
    ELSE
      NetSystem.WriteString(C, "Oberon System 3");
    END;  (* IF *)
    IF (aut # NIL) THEN
      NetTools.SendString(C, "Authorization: Basic ");
      NetSystem.WriteString(C, aut^.VAR21B);
    END;  (* IF *)
    NetTools.SendString(C, "User-Agent: ");
    NetSystem.WriteString(C, "HTTPDocs for Oberon (ejz)");
    cookie := FindCookie(cookies, host, path);
    WHILE (cookie # NIL) DO
      NetTools.SendString(C, "Cookie: ");
      NetTools.SendString(C, cookie^.VAR1CF);
      NetSystem.Write(C, "=");
      NetSystem.WriteString(C, cookie^.VAR1D7);
      cookie := cookie^.VAR1DF;
      cookie := FindCookie(cookie, host, path);
    END;  (* WHILE *)
    IF (method = "POST") & (query # NIL) & (query^.len > 0) THEN
      NetSystem.WriteString(C, "Content-Type: application/x-www-form-urlencoded");
      NetTools.SendString(C, "Content-Length: ");
      Strings.IntToStr(NetLen(query), str);
      NetSystem.WriteString(C, str);
      NetTools.SendString(C, Strings.CRLF);
      MIME.WriteText(query, 0, query^.len, OpenStream(C), MIME.textCont, FALSE);
    END;  (* IF *)
    NetTools.SendString(C, Strings.CRLF);
    NetTools.SendString(C, Strings.CRLF);
  END Request;


  PROCEDURE Response*(VAR C: NetSystem.Connection; key: LONGINT; main: BOOLEAN; VAR cont: MIME.Content; VAR location: ARRAY76; log: BOOLEAN): LONGINT;

    VAR
      time: LONGINT;
      status: LONGINT;
      pos: LONGINT;
      len: LONGINT;
      i: INTEGER;
      h: MIME.Header;
      base: HyperDocs.DefURL;

  BEGIN  (* PROCEDURE Response *)
    NEW(base);
    HyperDocs.RetrieveLink(key, buf);
    key := HTTPDocs0.SplitHTTPAdr(buf, base^.host, base^.path, base^.label, base^.port);
    status := 0;
    COPY("", location);
    NEW(cont);
    cont^.typ := MIME.GetContentType("text/plain");
    cont^.encoding := 0;
    cont^.len := 0;
    time := Input.Time();
    REPEAT
      IF log THEN
        HTTPDocs0.Wait();
      END;  (* IF *)
      len := NetSystem.Available(C);
    UNTIL ((((len > 0) OR ~NetTools.Connected(C, 2)) OR NetTools.UserBreak()) OR (Input.Time() > (time + NetTools.TimeOut)));
    IF (len <= 0) THEN
      IF log THEN
        Texts.WriteString(W, " no response");
        Texts.WriteLn(W);
        Texts.Append(Oberon.Log, W.buf);
      END;  (* IF *)
      NetTools.Disconnect(C);
      C := NIL;
      RETURN status;
    END;  (* IF *)
    NetSystem.ReadString(C, buf);
    IF (buf[0] = 000X) THEN
      RETURN status;
    ELSIF Strings.CAPPrefix("HTTP", buf) THEN
      i := 0;
      WHILE (buf[i] # 000X) & (buf[i] > " ") DO
        INC(i, 1);
      END;  (* WHILE *)
      Strings.StrToIntPos(buf, status, i);
      IF ~main & ((status < 200) OR (status >= 400)) THEN
        IF log THEN
          Texts.WriteLn(W);
          Texts.WriteString(W, buf);
          Texts.WriteLn(W);
          Texts.Append(Oberon.Log, W.buf);
        END;  (* IF *)
        NetTools.Disconnect(C);
        C := NIL;
        RETURN status;
      ELSIF (status = 204) THEN
        RETURN status;
      END;  (* IF *)
    ELSIF (buf[0] = "<") THEN
      cont^.typ := MIME.GetContentType("text/html");
      buf[0] := 000X;
    ELSE
      buf[0] := 000X;
    END;  (* IF *)
    IF (buf[0] # 000X) THEN
      MIME.ReadHeader(NetTools.OpenStream(C), NIL, h, len);
      pos := MIME.FindField(h, "Content-Type");
      IF (pos > 0) THEN
        MIME.ExtractContentType(h, pos, cont);
        IF log THEN
          Texts.Write(W, " ");
          Texts.WriteString(W, cont^.typ^.typ);
          Texts.Write(W, "/");
          Texts.WriteString(W, cont^.typ^.subTyp);
        END;  (* IF *)
        IF ~cont^.typ^.support THEN
          IF ~log THEN
            Texts.Write(W, " ");
            Texts.WriteString(W, cont^.typ^.typ);
            Texts.Write(W, "/");
            Texts.WriteString(W, cont^.typ^.subTyp);
          END;  (* IF *)
          Texts.WriteString(W, " not supported");
          Texts.WriteLn(W);
          Texts.Append(Oberon.Log, W.buf);
        END;  (* IF *)
        IF (cont^.typ^.typ = "text") THEN
          pos := MIME.FindField(h, "Content-Transfer-Encoding");
          MIME.TextEncoding(h, pos, cont);
        END;  (* IF *)
      END;  (* IF *)
      pos := MIME.FindField(h, "Content-Length");
      IF (pos > 0) THEN
        MIME.ExtractValue(h, pos, buf);
        Strings.StrToInt(buf, cont^.len);
      END;  (* IF *)
      pos := MIME.FindField(h, "Location");
      IF (pos > 0) & (status >= 300) THEN
        MIME.ExtractValue(h, pos, location);
      END;  (* IF *)
      pos := MIME.FindField(h, "Set-Cookie");
      IF (pos > 0) THEN
        MIME.ExtractValue(h, pos, buf);
        AddCookie(base^.host, base^.path, buf);
      END;  (* IF *)
    END;  (* IF *)
    IF log THEN
      Texts.WriteLn(W);
      Texts.Append(Oberon.Log, W.buf);
    END;  (* IF *)
    RETURN status;
  END Response;


BEGIN  (* MODULE HTTPDocs *)
  InitTables();
  Texts.OpenWriter(W);
  NEW(HTTPDocs0.httpProxy);
  HTTPDocs0.requestDoc := (requestDoc);
  NetTools.GetHostPort("HTTPProxy", HTTPDocs0.httpProxy^.host, HTTPDocs0.httpProxy^.port, 80);
  IF (HTTPDocs0.httpProxy^.host[0] = 000X) THEN
    HTTPDocs0.httpProxy := NIL;
  END;  (* IF *)
  noWorkers := 0;
  authorizations := NIL;
  cookies := NIL;
END HTTPDocs.
