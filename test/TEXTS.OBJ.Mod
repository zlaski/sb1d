(***************************************************************************

   Input File:   TEXTS.OBJ
   Date/Time:    Tue Jan 12 23:22:04 2021
   -------------------------------------------------------

   Generated by Slim Binary(tm) Decoder Version 2.04

 ***************************************************************************)

MODULE Texts;    (* Slim Binary(tm) *)

  IMPORT
    Files, Objects, Display, FileDir, Fonts, Reals;

  CONST
    CR = 00DX;
    OldTextBlockId = 001X;
    OldTextSpex = 0F0X;
    TAB = 009X;
    Char* = 6;
    Int* = 3;
    Inval* = 0;
    LongReal* = 5;
    Name* = 1;
    Object* = 7;
    Real* = 4;
    String* = 2;

  TYPE
    Piece = POINTER TO PieceDesc;
    PieceDesc = RECORD
      VARBF: Files.File;
      VARC1: LONGINT;
      VARC3: LONGINT;
      VARCB: Objects.Object;
      VARD4: Objects.Library;
      VARD6: INTEGER;
      VARD8: SHORTINT;
      VARDA: SHORTINT;
      VARDC: Piece;
      VARDE: Piece;
    END;
    BufDesc* = RECORD
      len*: LONGINT;
      VARE5: Piece;
      VARE7: Piece;
    END;
    Buffer* = POINTER TO BufDesc;
    Writer* = RECORD
      VAR9D: Files.Rider;
      buf*: Buffer;
      lib*: Objects.Library;
      col*: SHORTINT;
      voff*: SHORTINT;
    END;
    ARRAY105 = ARRAY OF CHAR;
    TextDesc* = RECORD(Objects.ObjDesc)
      len*: LONGINT;
      VAR240: Objects.Library;
      VAR242: Piece;
      VAR244: LONGINT;
      VAR246: Piece;
    END;
    Text* = POINTER TO TextDesc;
    Reader* = RECORD
      VAR2AE: Piece;
      VAR2B0: Text;
      VAR2B2: LONGINT;
      VAR2B4: LONGINT;
      VAR2B8: Files.Rider;
      eot*: BOOLEAN;
      lib*: Objects.Library;
      col*: SHORTINT;
      voff*: SHORTINT;
    END;
    ARRAY2F3 = ARRAY 64 OF CHAR;
    Scanner* = RECORD(Reader)
      nextCh*: CHAR;
      line*: INTEGER;
      class*: INTEGER;
      i*: LONGINT;
      x*: REAL;
      y*: LONGREAL;
      c*: CHAR;
      len*: SHORTINT;
      s*: ARRAY2F3;
      obj*: Objects.Object;
    END;
    Finder* = RECORD
      eot*: BOOLEAN;
      pos*: LONGINT;
      VAR3B4: Text;
      VAR3B6: Piece;
    END;
    ARRAY3D8 = ARRAY OF CHAR;
    UpdateMsg* = RECORD(Display.FrameMsg)
      text*: Text;
      beg*: LONGINT;
      end*: LONGINT;
      len*: LONGINT;
    END;
    ARRAY50F = ARRAY 256 OF BOOLEAN;

  VAR
    TextBlockId*: CHAR;
    obs: Objects.Library;
    nameChars: ARRAY50F;
    Wfile: Files.File;
    TextSpex: CHAR;
    R: Files.Rider;
    NoSpex2: CHAR;
    NoSpex: CHAR;
    H: Objects.Handler;
    DocBlockId: CHAR;
    DelBuf: Buffer;

  (* Forward PROCEDURE declarations *)

  PROCEDURE^ FindPiece(T: Text; pos: LONGINT; VAR org: LONGINT; VAR p: Piece);
  PROCEDURE^ GenAscii(T: Text; f: Files.File);
  PROCEDURE^ GenNew(T: Text);
  PROCEDURE^ InitScan();
  PROCEDURE^ ReadDocHeader(VAR R: Files.Rider);
  PROCEDURE^ SplitPiece(p: Piece; off: LONGINT; VAR pr: Piece);
  PROCEDURE^ SyncPiece(T: Text; p: Piece);
  PROCEDURE^ Append*(T: Text; B: Buffer);
  PROCEDURE^ ChangeLooks*(T: Text; beg: LONGINT; end: LONGINT; sel: SET; lib: Objects.Library; col: SHORTINT; voff: SHORTINT);
  PROCEDURE^ Copy*(SB: Buffer; DB: Buffer);
  PROCEDURE^ Delete*(T: Text; beg: LONGINT; end: LONGINT);
  PROCEDURE^ FindObj*(VAR F: Finder; VAR obj: Objects.Object);
  PROCEDURE^ Handle*(obj: Objects.Object; VAR M: Objects.ObjMsg);
  PROCEDURE^ Insert*(T: Text; pos: LONGINT; B: Buffer);
  PROCEDURE^ Load*(T: Text; f: Files.File; pos: LONGINT; VAR len: LONGINT);
  PROCEDURE^ New*();
  PROCEDURE^ Open*(T: Text; name: ARRAY3D8);
  PROCEDURE^ OpenBuf*(B: Buffer);
  PROCEDURE^ OpenFinder*(VAR F: Finder; T: Text; pos: LONGINT);
  PROCEDURE^ OpenReader*(VAR R: Reader; T: Text; pos: LONGINT);
  PROCEDURE^ OpenScanner*(VAR S: Scanner; T: Text; pos: LONGINT);
  PROCEDURE^ OpenWriter*(VAR W: Writer);
  PROCEDURE^ Pos*(VAR R: Reader): LONGINT;
  PROCEDURE^ Read*(VAR R: Reader; VAR ch: CHAR);
  PROCEDURE^ Recall*(VAR B: Buffer);
  PROCEDURE^ Replace*(T: Text; beg: LONGINT; end: LONGINT; B: Buffer);
  PROCEDURE^ Save*(T: Text; beg: LONGINT; end: LONGINT; B: Buffer);
  PROCEDURE^ Scan*(VAR S: Scanner);
  PROCEDURE^ SetColor*(VAR W: Writer; col: SHORTINT);
  PROCEDURE^ SetFont*(VAR W: Writer; fnt: Objects.Library);
  PROCEDURE^ SetOffset*(VAR W: Writer; voff: SHORTINT);
  PROCEDURE^ Store*(T: Text; f: Files.File; pos: LONGINT; VAR len: LONGINT);
  PROCEDURE^ Write*(VAR W: Writer; ch: CHAR);
  PROCEDURE^ WriteDate*(VAR W: Writer; t: LONGINT; d: LONGINT);
  PROCEDURE^ WriteHex*(VAR W: Writer; x: LONGINT);
  PROCEDURE^ WriteInt*(VAR W: Writer; x: LONGINT; n: LONGINT);
  PROCEDURE^ WriteLn*(VAR W: Writer);
  PROCEDURE^ WriteLongReal*(VAR W: Writer; x: LONGREAL; n: LONGINT);
  PROCEDURE^ WriteLongRealFix*(VAR W: Writer; x: LONGREAL; n: LONGINT; f: LONGINT; D: LONGINT);
  PROCEDURE^ WriteLongRealHex*(VAR W: Writer; x: LONGREAL);
  PROCEDURE^ WriteObj*(VAR W: Writer; obj: Objects.Object);
  PROCEDURE^ WriteReal*(VAR W: Writer; x: REAL; n: LONGINT);
  PROCEDURE^ WriteRealFix*(VAR W: Writer; x: REAL; n: LONGINT; f: LONGINT; E: LONGINT);
  PROCEDURE^ WriteRealHex*(VAR W: Writer; x: REAL);
  PROCEDURE^ WriteSet*(VAR W: Writer; s: SET);
  PROCEDURE^ WriteString*(VAR W: Writer; s: ARRAY105);

  PROCEDURE FindPiece(T: Text; pos: LONGINT; VAR org: LONGINT; VAR p: Piece);

    VAR
      n: INTEGER;

  BEGIN  (* PROCEDURE FindPiece *)
    IF (pos < T.VAR244) THEN
      T.VAR244 := -1;
      T.VAR246 := T.VAR242;
    END;  (* IF *)
    org := T.VAR244;
    p := T.VAR246;
    n := 0;
    WHILE (pos >= (org + p.VARC3)) DO
      org := (org + p.VARC3);
      p := p.VARDE;
      INC(n, 1);
    END;  (* WHILE *)
    IF (n > 50) THEN
      T.VAR244 := org;
      T.VAR246 := p;
    END;  (* IF *)
  END FindPiece;


  PROCEDURE GenAscii(T: Text; f: Files.File);

    VAR
      q: Piece;
      len: LONGINT;
      Q: Piece;

  BEGIN  (* PROCEDURE GenAscii *)
    len := Files.Length(f);
    NEW(Q);
    Q.VARBF := Wfile;
    Q.VARC1 := 0;
    Q.VARC3 := 1;
    Q.VARD6 := -32768;
    Q.VARD4 := NIL;
    Q.VARD8 := 127;
    Q.VARDA := 0;
    NEW(q);
    q.VARBF := f;
    q.VARC1 := 0;
    q.VARC3 := len;
    q.VARD6 := -32768;
    q.VARD4 := Fonts.Default;
    q.VARD8 := 15;
    q.VARDA := 0;
    Q.VARDE := q;
    q.VARDC := Q;
    q.VARDE := Q;
    Q.VARDC := q;
    T.handle := H;
    T.VAR240 := NIL;
    T.VAR242 := Q;
    T.len := len;
    T.VAR244 := -1;
    T.VAR246 := T.VAR242;
  END GenAscii;


  PROCEDURE GenNew(T: Text);

    VAR
      Q: Piece;

  BEGIN  (* PROCEDURE GenNew *)
    NEW(Q);
    Q.VARBF := Wfile;
    Q.VARC1 := 0;
    Q.VARC3 := 1;
    Q.VARD6 := -32768;
    Q.VARD4 := NIL;
    Q.VARD8 := 127;
    Q.VARDA := 0;
    Q.VARDE := Q;
    Q.VARDC := Q;
    T.handle := H;
    T.VAR240 := NIL;
    T.VAR242 := Q;
    T.len := 0;
    T.VAR244 := -1;
    T.VAR246 := T.VAR242;
  END GenNew;


  PROCEDURE InitScan();

    VAR
      i: INTEGER;
      ch: CHAR;

  BEGIN  (* PROCEDURE InitScan *)
    i := 0;
    WHILE (i <= 255) DO
      ch := CHR(i);
      nameChars[i] := (((((CAP(ch) >= "A") & (CAP(ch) <= "Z") OR (ch >= "0") & (ch <= "9")) OR (ch = "@")) OR (ch = ".")) OR FileDir.SpecialChar(ch));
      INC(i, 1);
    END;  (* WHILE *)
  END InitScan;


  PROCEDURE ReadDocHeader(VAR R: Files.Rider);

    TYPE
      ARRAY9A0 = ARRAY 32 OF CHAR;

    VAR
      y: INTEGER;
      x: INTEGER;
      w: INTEGER;
      name: ARRAY9A0;
      h: INTEGER;
      ch: CHAR;

  BEGIN  (* PROCEDURE ReadDocHeader *)
    Files.Read(R, ch);
    Files.ReadString(R, name);
    Files.ReadInt(R, x);
    Files.ReadInt(R, y);
    Files.ReadInt(R, w);
    Files.ReadInt(R, h);
  END ReadDocHeader;


  PROCEDURE SplitPiece(p: Piece; off: LONGINT; VAR pr: Piece);

    VAR
      q: Piece;

  BEGIN  (* PROCEDURE SplitPiece *)
    IF (off > 0) THEN
      NEW(q);
      q.VARD6 := -32768;
      q.VARD4 := p.VARD4;
      q.VARD8 := p.VARD8;
      q.VARDA := p.VARDA;
      q.VARC3 := (p.VARC3 - off);
      q.VARBF := p.VARBF;
      q.VARC1 := (p.VARC1 + off);
      p.VARC3 := off;
      q.VARDE := p.VARDE;
      p.VARDE := q;
      q.VARDC := p;
      q.VARDE.VARDC := q;
      pr := q;
    ELSE
      pr := p;
    END;  (* IF *)
  END SplitPiece;


  PROCEDURE SyncPiece(T: Text; p: Piece);

    VAR
      ch: CHAR;
      R: Files.Rider;

  BEGIN  (* PROCEDURE SyncPiece *)
    IF (p.VARD6 >= 0) & (p.VARCB = NIL) & ~(p.VARD4 IS Fonts.Font) THEN
      T.VAR240.GetObj(T.VAR240, p.VARD6, p.VARCB);
      Files.Set(R, p.VARBF, p.VARC1);
      Files.Read(R, ch);
      p.VARD4.PutObj(p.VARD4, ORD(ch), p.VARCB);
    END;  (* IF *)
  END SyncPiece;


  PROCEDURE Append*(T: Text; B: Buffer);

  BEGIN  (* PROCEDURE Append *)
    Insert(T, T.len, B);
  END Append;


  PROCEDURE ChangeLooks*(T: Text; beg: LONGINT; end: LONGINT; sel: SET; lib: Objects.Library; col: SHORTINT; voff: SHORTINT);

    VAR
      pe: Piece;
      pb: Piece;
      p: Piece;
      org: LONGINT;
      M: UpdateMsg;
      A: Objects.AttrMsg;

  BEGIN  (* PROCEDURE ChangeLooks *)
    IF (beg < end) THEN
      FindPiece(T, beg, org, p);
      SplitPiece(p, beg - org, pb);
      FindPiece(T, end, org, p);
      SplitPiece(p, end - org, pe);
      p := pb;
      REPEAT
        IF (0 IN sel) & (p.VARD4 IS Fonts.Font) THEN
          p.VARD4 := lib;
        ELSIF ~(p.VARD4 IS Fonts.Font) THEN
          SyncPiece(T, p);
          IF (p.VARCB # NIL) & (p.VARCB.handle # NIL) THEN
            IF (1 IN sel) THEN
              A.id := 1;
              A.name := "Color";
              A.class := 0;
              A.res := -1;
              p.VARCB.handle(p.VARCB, A);
              IF (A.res = 0) THEN
                A.id := 2;
                A.class := 3;
                A.i := col;
                p.VARCB.handle(p.VARCB, A);
              END;  (* IF *)
            END;  (* IF *)
            IF (0 IN sel) & (lib # NIL) & (lib IS Fonts.Font) THEN
              A.id := 1;
              A.name := "Font";
              A.class := 0;
              A.res := -1;
              p.VARCB.handle(p.VARCB, A);
              IF (A.res = 0) THEN
                A.id := 2;
                A.class := 2;
                COPY(lib(Fonts.Font).name, A.s);
                p.VARCB.handle(p.VARCB, A);
              END;  (* IF *)
            END;  (* IF *)
          END;  (* IF *)
        END;  (* IF *)
        IF (1 IN sel) THEN
          p.VARD8 := col;
        END;  (* IF *)
        IF (2 IN sel) THEN
          p.VARDA := voff;
        END;  (* IF *)
        p := p.VARDE;
      UNTIL (p = pe);
      M.text := T;
      M.F := NIL;
      M.beg := beg;
      M.end := end;
      M.len := (end - beg);
      Display.Broadcast(M);
    END;  (* IF *)
  END ChangeLooks;


  PROCEDURE Copy*(SB: Buffer; DB: Buffer);

    VAR
      q: Piece;
      p: Piece;
      Q: Piece;

  BEGIN  (* PROCEDURE Copy *)
    p := SB.VARE5;
    Q := DB.VARE7;
    WHILE (p # SB.VARE7) DO
      p := p.VARDE;
      NEW(q);
      q.VARD6 := -32768;
      q(PieceDesc) := p;
      Q.VARDE := q;
      q.VARDC := Q;
      Q := q;
    END;  (* WHILE *)
    DB.VARE7 := Q;
    DB.len := (DB.len + SB.len);
  END Copy;


  PROCEDURE Delete*(T: Text; beg: LONGINT; end: LONGINT);

    VAR
      per: Piece;
      pe: Piece;
      pbr: Piece;
      pb: Piece;
      orge: LONGINT;
      orgb: LONGINT;
      M: UpdateMsg;

  BEGIN  (* PROCEDURE Delete *)
    IF (beg < end) THEN
      FindPiece(T, beg, orgb, pb);
      SplitPiece(pb, beg - orgb, pbr);
      FindPiece(T, end, orge, pe);
      SplitPiece(pe, end - orge, per);
      IF (T.VAR244 >= orgb) THEN
        T.VAR244 := (orgb - pb.VARDC.VARC3);
        T.VAR246 := pb.VARDC;
      END;  (* IF *)
      DelBuf.VARE5.VARDE := pbr;
      DelBuf.VARE7 := per.VARDC;
      DelBuf.VARE7.VARDE := NIL;
      DelBuf.len := (end - beg);
      per.VARDC := pbr.VARDC;
      pbr.VARDC.VARDE := per;
      T.len := ((T.len - end) + beg);
      M.text := T;
      M.F := NIL;
      M.beg := beg;
      M.end := end;
      M.len := 0;
      Display.Broadcast(M);
    END;  (* IF *)
  END Delete;


  PROCEDURE FindObj*(VAR F: Finder; VAR obj: Objects.Object);

    VAR
      p: Piece;
      org: LONGINT;

  BEGIN  (* PROCEDURE FindObj *)
    obj := F.VAR3B6.VARCB;
    IF (obj = NIL) THEN
      SyncPiece(F.VAR3B4, F.VAR3B6);
      obj := F.VAR3B6.VARCB;
    END;  (* IF *)
    IF (F.VAR3B6.VARBF = Wfile) THEN
      F.eot := TRUE;
    END;  (* IF *)
    org := F.pos;
    p := F.VAR3B6;
    REPEAT
      org := (org + p.VARC3);
      p := p.VARDE;
    UNTIL ((p.VARBF = Wfile) OR ~(p.VARD4 IS Fonts.Font));
    F.pos := org;
    F.VAR3B6 := p;
  END FindObj;


  PROCEDURE Handle*(obj: Objects.Object; VAR M: Objects.ObjMsg);

    VAR
      len: LONGINT;
      id: INTEGER;
      ch: CHAR;
      T: Text;
      B: Buffer;

  BEGIN  (* PROCEDURE Handle *)
    WITH obj: Text DO
      IF (M IS Objects.AttrMsg) THEN
        WITH M: Objects.AttrMsg DO
          IF (M.name = "Gen") THEN
            M.s := "Texts.New";
          END;  (* IF *)
        END;  (* WITH *)
      ELSIF (M IS Objects.CopyMsg) THEN
        WITH M: Objects.CopyMsg DO
          NEW(B);
          OpenBuf(B);
          Save(obj, 0, obj.len, B);
          NEW(T);
          T.handle := obj.handle;
          GenNew(T);
          Insert(T, 0, B);
          M.obj := T;
        END;  (* WITH *)
      ELSIF (M IS Objects.BindMsg) THEN
        WITH M: Objects.BindMsg DO
          IF ((obj.lib = NIL) OR (obj.lib.name[0] = 000X) & (obj.lib # M.lib)) THEN
            M.lib.GenRef(M.lib, id);
            M.lib.PutObj(M.lib, id, obj);
          END;  (* IF *)
        END;  (* WITH *)
      ELSIF (M IS Objects.FileMsg) THEN
        WITH M: Objects.FileMsg DO
          IF (M.id = 0) THEN
            Files.Read(M.R, ch);
            IF (ch = DocBlockId) THEN
              ReadDocHeader(R);
              Files.Read(R, ch);
            END;  (* IF *)
            IF ((ch = TextBlockId) OR (ch = 001X)) THEN
              Load(obj, Files.Base(M.R), Files.Pos(M.R), len);
              Files.Set(M.R, Files.Base(M.R), (Files.Pos(M.R) + len));
            END;  (* IF *)
          ELSE
            Store(obj, Files.Base(M.R), Files.Pos(M.R), len);
            Files.Set(M.R, Files.Base(M.R), (Files.Pos(M.R) + len));
          END;  (* IF *)
        END;  (* WITH *)
      END;  (* IF *)
    END;  (* WITH *)
  END Handle;


  PROCEDURE Insert*(T: Text; pos: LONGINT; B: Buffer);

    VAR
      qe: Piece;
      qb: Piece;
      pr: Piece;
      pl: Piece;
      p: Piece;
      org: LONGINT;
      M: UpdateMsg;

  BEGIN  (* PROCEDURE Insert *)
    FindPiece(T, pos, org, p);
    SplitPiece(p, pos - org, pr);
    IF (T.VAR244 >= org) THEN
      T.VAR244 := (org - p.VARDC.VARC3);
      T.VAR246 := p.VARDC;
    END;  (* IF *)
    pl := pr.VARDC;
    qb := B.VARE5.VARDE;
    IF (qb # NIL) & (qb.VARBF = pl.VARBF) & (qb.VARC1 = (pl.VARC1 + pl.VARC3)) & (pl.VARD4 IS Fonts.Font) & (pl.VARD4 = qb.VARD4) & (pl.VARD8 = qb.VARD8) & (pl.VARDA = qb.VARDA) THEN
      pl.VARC3 := (pl.VARC3 + qb.VARC3);
      qb := qb.VARDE;
    END;  (* IF *)
    IF (qb # NIL) THEN
      qe := B.VARE7;
      qb.VARDC := pl;
      pl.VARDE := qb;
      qe.VARDE := pr;
      pr.VARDC := qe;
    END;  (* IF *)
    T.len := (T.len + B.len);
    M.text := T;
    M.F := NIL;
    M.beg := pos;
    M.end := pos;
    M.len := B.len;
    B.VARE7 := B.VARE5;
    B.VARE7.VARDE := NIL;
    B.len := 0;
    Display.Broadcast(M);
  END Insert;


  PROCEDURE Load*(T: Text; f: Files.File; pos: LONGINT; VAR len: LONGINT);

    TYPE
      ARRAYA00 = ARRAY 32 OF CHAR;
      ARRAYA0A = ARRAY 32 OF Objects.Library;

    VAR
      type: CHAR;
      tlen: LONGINT;
      tag: CHAR;
      ref: CHAR;
      q: Piece;
      p: Piece;
      off: LONGINT;
      lib: SHORTINT;
      i: INTEGER;
      hlen: LONGINT;
      flen: LONGINT;
      S: Files.Rider;
      R: Files.Rider;
      Q: Piece;
      N: SHORTINT;
      LName: ARRAYA00;
      Dict: ARRAYA0A;

  BEGIN  (* PROCEDURE Load *)
    NEW(Q);
    Q.VARBF := Wfile;
    Q.VARC1 := 0;
    Q.VARC3 := 1;
    Q.VARD6 := -32768;
    Q.VARD4 := NIL;
    Q.VARD8 := 127;
    Q.VARDA := 0;
    p := Q;
    Files.Set(R, f, pos);
    Files.Read(R, type);
    Files.ReadLInt(R, hlen);
    Files.Set(S, f, (((pos - 1) + hlen) - 4));
    Files.ReadLInt(S, tlen);
    IF ((type = TextSpex) OR (type = 0F0X)) THEN
      T.VAR240 := NIL;
      flen := 0;
    ELSE
      NEW(T.VAR240);
      Objects.OpenLibrary(T.VAR240);
      Files.Set(S, f, (((pos - 1) + hlen) + tlen));
      Files.Read(S, tag);
      IF (tag = Objects.LibBlockId) THEN
        Objects.LoadLibrary(T.VAR240, f, ((((pos - 1) + hlen) + tlen) + 1), flen);
      END;  (* IF *)
      INC(flen, 1);
    END;  (* IF *)
    Dict[0] := T.VAR240;
    N := 1;
    off := ((pos - 1) + hlen);
    WHILE (Files.Pos(R) < (((pos - 1) + hlen) - 5)) DO
      Files.Read(R, lib);
      IF (lib = N) THEN
        Files.ReadString(R, LName);
        Dict[N] := Objects.ThisLibrary(LName);
        INC(N, 1);
      END;  (* IF *)
      NEW(q);
      q.VARD4 := Dict[lib];
      q.VARCB := NIL;
      IF ~(q.VARD4 IS Fonts.Font) THEN
        Files.Set(S, f, off);
        Files.Read(S, ref);
        q.VARD6 := ORD(ref);
      ELSE
        q.VARD6 := -32768;
      END;  (* IF *)
      Files.Read(R, q.VARD8);
      Files.Read(R, q.VARDA);
      Files.ReadLInt(R, q.VARC3);
      IF (q.VARC3 < 0) THEN
        GenAscii(T, f);
        RETURN;
      END;  (* IF *)
      q.VARBF := f;
      q.VARC1 := off;
      off := (off + q.VARC3);
      p.VARDE := q;
      q.VARDC := p;
      p := q;
    END;  (* WHILE *)
    p.VARDE := Q;
    Q.VARDC := p;
    T.handle := H;
    T.VAR242 := Q;
    T.len := tlen;
    T.VAR244 := -1;
    T.VAR246 := T.VAR242;
    IF (type = NoSpex2) THEN
      i := 0;
      WHILE (i <= 31) DO
        Dict[i] := NIL;
        INC(i, 1);
      END;  (* WHILE *)
      Files.Set(R, f, ((((pos - 1) + hlen) + tlen) + flen));
      p := T.VAR242.VARDE;
      WHILE (p # T.VAR242) DO
        IF (p.VARD4 = T.VAR240) THEN
          Files.ReadInt(R, i);
          INC(flen, 2);
          IF (Dict[ASH(i, -8)] = NIL) THEN
            NEW(Dict[ASH(i, -8)]);
            Objects.OpenLibrary(Dict[ASH(i, -8)]);
          END;  (* IF *)
          p.VARCB := NIL;
          p.VARD6 := i;
          p.VARD4 := Dict[ASH(i, -8)];
        END;  (* IF *)
        p := p.VARDE;
      END;  (* WHILE *)
    END;  (* IF *)
    len := (((hlen - 1) + tlen) + flen);
  END Load;


  PROCEDURE New*();

    VAR
      T: Text;

  BEGIN  (* PROCEDURE New *)
    NEW(T);
    T.handle := H;
    GenNew(T);
    Objects.NewObj := T;
  END New;


  PROCEDURE Open*(T: Text; name: ARRAY3D8);

    VAR
      len: LONGINT;
      f: Files.File;
      ch: CHAR;
      R: Files.Rider;

  BEGIN  (* PROCEDURE Open *)
    obs := NIL;
    f := Files.Old(name);
    IF (f # NIL) THEN
      Files.Set(R, f, 0);
      Files.Read(R, ch);
      IF (ch = DocBlockId) THEN
        ReadDocHeader(R);
        Files.Read(R, ch);
        IF (ch = 0F7X) THEN
          Files.Read(R, ch);
          IF (ch = 008X) THEN
            Files.ReadLInt(R, len);
            Files.Set(R, f, (Files.Pos(R) + len));
            Files.Read(R, ch);
          END;  (* IF *)
        END;  (* IF *)
      END;  (* IF *)
      IF ((ch = TextBlockId) OR (ch = 001X)) THEN
        Load(T, f, Files.Pos(R), len);
      ELSE
        GenAscii(T, f);
      END;  (* IF *)
    ELSE
      GenNew(T);
    END;  (* IF *)
  END Open;


  PROCEDURE OpenBuf*(B: Buffer);

  BEGIN  (* PROCEDURE OpenBuf *)
    NEW(B.VARE5);
    B.VARE5.VARD6 := -32768;
    B.VARE7 := B.VARE5;
    B.len := 0;
  END OpenBuf;


  PROCEDURE OpenFinder*(VAR F: Finder; T: Text; pos: LONGINT);

    VAR
      p: Piece;
      org: LONGINT;

  BEGIN  (* PROCEDURE OpenFinder *)
    FindPiece(T, pos, org, p);
    F.VAR3B4 := T;
    WHILE (p.VARBF # Wfile) & (p.VARD4 IS Fonts.Font) DO
      org := (org + p.VARC3);
      p := p.VARDE;
    END;  (* WHILE *)
    F.pos := org;
    F.VAR3B6 := p;
    F.eot := FALSE;
  END OpenFinder;


  PROCEDURE OpenReader*(VAR R: Reader; T: Text; pos: LONGINT);

    VAR
      p: Piece;
      org: LONGINT;

  BEGIN  (* PROCEDURE OpenReader *)
    FindPiece(T, pos, org, p);
    R.VAR2B0 := T;
    R.lib := NIL;
    R.VAR2AE := p;
    R.VAR2B2 := org;
    R.VAR2B4 := (pos - org);
    IF (p.VARD6 >= 0) THEN
      SyncPiece(T, p);
    END;  (* IF *)
    Files.Set(R.VAR2B8, R.VAR2AE.VARBF, R.VAR2AE.VARC1 + R.VAR2B4);
    R.eot := FALSE;
  END OpenReader;


  PROCEDURE OpenScanner*(VAR S: Scanner; T: Text; pos: LONGINT);

  BEGIN  (* PROCEDURE OpenScanner *)
    OpenReader(S, T, pos);
    S.line := 0;
    Read(S, S.nextCh);
  END OpenScanner;


  PROCEDURE OpenWriter*(VAR W: Writer);

  BEGIN  (* PROCEDURE OpenWriter *)
    NEW(W.buf);
    OpenBuf(W.buf);
    W.lib := Fonts.Default;
    W.col := 15;
    W.voff := 0;
    Files.Set(W.VAR9D, Files.New(""), 0);
  END OpenWriter;


  PROCEDURE Pos*(VAR R: Reader): LONGINT;

  BEGIN  (* PROCEDURE Pos *)
    RETURN (R.VAR2B2 + R.VAR2B4);
  END Pos;


  PROCEDURE Read*(VAR R: Reader; VAR ch: CHAR);

  BEGIN  (* PROCEDURE Read *)
    Files.Read(R.VAR2B8, ch);
    R.lib := R.VAR2AE.VARD4;
    R.col := R.VAR2AE.VARD8;
    R.voff := R.VAR2AE.VARDA;
    INC(R.VAR2B4, 1);
    IF (R.VAR2B4 >= R.VAR2AE.VARC3) THEN
      IF (R.VAR2AE.VARBF = Wfile) THEN
        R.eot := TRUE;
      END;  (* IF *)
      R.VAR2B2 := (R.VAR2B2 + R.VAR2AE.VARC3);
      R.VAR2AE := R.VAR2AE.VARDE;
      R.VAR2B4 := 0;
      IF (R.VAR2AE.VARD6 >= 0) THEN
        SyncPiece(R.VAR2B0, R.VAR2AE);
      END;  (* IF *)
      Files.Set(R.VAR2B8, R.VAR2AE.VARBF, R.VAR2AE.VARC1);
    END;  (* IF *)
  END Read;


  PROCEDURE Recall*(VAR B: Buffer);

  BEGIN  (* PROCEDURE Recall *)
    Copy(DelBuf, B);
  END Recall;


  PROCEDURE Replace*(T: Text; beg: LONGINT; end: LONGINT; B: Buffer);

    VAR
      qe: Piece;
      qb: Piece;
      pl: Piece;
      per: Piece;
      pe: Piece;
      pbr: Piece;
      pb: Piece;
      orge: LONGINT;
      orgb: LONGINT;
      M: UpdateMsg;

  BEGIN  (* PROCEDURE Replace *)
    IF (beg < end) THEN
      FindPiece(T, beg, orgb, pb);
      SplitPiece(pb, beg - orgb, pbr);
      FindPiece(T, end, orge, pe);
      SplitPiece(pe, end - orge, per);
      IF (T.VAR244 >= orgb) THEN
        T.VAR244 := (orgb - pb.VARDC.VARC3);
        T.VAR246 := pb.VARDC;
      END;  (* IF *)
      DelBuf.VARE5.VARDE := pbr;
      DelBuf.VARE7 := per.VARDC;
      DelBuf.VARE7.VARDE := NIL;
      DelBuf.len := (end - beg);
      per.VARDC := pbr.VARDC;
      pbr.VARDC.VARDE := per;
      pl := pbr.VARDC;
      qb := B.VARE5.VARDE;
      IF (qb # NIL) & (qb.VARBF = pl.VARBF) & (qb.VARC1 = (pl.VARC1 + pl.VARC3)) & (pl.VARD4 IS Fonts.Font) & (pl.VARD4 = qb.VARD4) & (pl.VARD8 = qb.VARD8) & (pl.VARDA = qb.VARDA) THEN
        pl.VARC3 := (pl.VARC3 + qb.VARC3);
        qb := qb.VARDE;
      END;  (* IF *)
      IF (qb # NIL) THEN
        qe := B.VARE7;
        qb.VARDC := pl;
        pl.VARDE := qb;
        qe.VARDE := per;
        per.VARDC := qe;
      END;  (* IF *)
      T.len := (((T.len - end) + beg) + B.len);
      M.text := T;
      M.F := NIL;
      M.beg := beg;
      M.end := end;
      M.len := B.len;
      B.VARE7 := B.VARE5;
      B.VARE7.VARDE := NIL;
      B.len := 0;
      Display.Broadcast(M);
    END;  (* IF *)
  END Replace;


  PROCEDURE Save*(T: Text; beg: LONGINT; end: LONGINT; B: Buffer);

    VAR
      qe: Piece;
      qb: Piece;
      q: Piece;
      p: Piece;
      org: LONGINT;

  BEGIN  (* PROCEDURE Save *)
    IF (beg < end) THEN
      FindPiece(T, beg, org, p);
      SyncPiece(T, p);
      NEW(qb);
      qb(PieceDesc) := p;
      qb.VARD6 := -32768;
      qb.VARC3 := (qb.VARC3 - (beg - org));
      qb.VARC1 := (qb.VARC1 + (beg - org));
      qe := qb;
      WHILE (end > (org + p.VARC3)) DO
        org := (org + p.VARC3);
        p := p.VARDE;
        SyncPiece(T, p);
        NEW(q);
        q(PieceDesc) := p;
        q.VARD6 := -32768;
        qe.VARDE := q;
        q.VARDC := qe;
        qe := q;
      END;  (* WHILE *)
      qe.VARDE := NIL;
      qe.VARC3 := (qe.VARC3 - ((org + p.VARC3) - end));
      B.VARE7.VARDE := qb;
      qb.VARDC := B.VARE7;
      B.VARE7 := qe;
      B.len := (B.len + (end - beg));
    END;  (* IF *)
  END Save;


  PROCEDURE Scan*(VAR S: Scanner);

    CONST
      maxD = 32;

    TYPE
      ARRAY1718 = ARRAY 32 OF CHAR;

    VAR
      y: LONGREAL;
      sign: BOOLEAN;
      negE: BOOLEAN;
      neg: BOOLEAN;
      k3: LONGINT;
      k2: LONGINT;
      k1: LONGINT;
      k: LONGINT;
      j: SHORTINT;
      i: SHORTINT;
      hex: BOOLEAN;
      h: SHORTINT;
      e: INTEGER;
      d: ARRAY1718;
      ch: CHAR;
      E: CHAR;

  BEGIN  (* PROCEDURE Scan *)
    ch := S.nextCh;
    i := 0;
    LOOP
      IF ((S.lib = NIL) OR ~(S.lib IS Fonts.Font)) THEN
        EXIT;
      ELSIF (ch = 00DX) THEN
        INC(S.line, 1);
      ELSIF (ch # " ") & (ch # 009X) THEN
        EXIT;
      END;  (* IF *)
      Read(S, ch);
    END;  (* LOOP *)
    IF (S.lib = NIL) THEN
      S.class := 0;
      S.eot := TRUE;
      Read(S, ch);
    ELSIF ~(S.lib IS Fonts.Font) THEN
      S.class := 7;
      S.lib.GetObj(S.lib, ORD(ch), S.obj);
      Read(S, ch);
    ELSIF (((("A" <= CAP(ch)) & (CAP(ch) <= "Z") OR (ch = ".")) OR (ch = "_")) OR (ch = FileDir.PathChar)) THEN
      REPEAT
        S.s[i] := ch;
        INC(i, 1);
        Read(S, ch);
      UNTIL ((~nameChars[ORD(ch)] OR ~(S.lib IS Fonts.Font)) OR (i = 63));
      S.s[i] := 000X;
      IF FileDir.SpecialChar(S.s[0]) & (i = 1) THEN
        S.c := S.s[0];
        S.class := 6;
      ELSE
        S.len := i;
        S.class := 1;
      END;  (* IF *)
    ELSIF (ch = 022X) THEN
      Read(S, ch);
      WHILE (ch # 022X) & (ch >= " ") & (S.lib IS Fonts.Font) & (i # 63) DO
        S.s[i] := ch;
        INC(i, 1);
        Read(S, ch);
      END;  (* WHILE *)
      S.s[i] := 000X;
      S.len := i;
      Read(S, ch);
      S.class := 2;
    ELSE
      IF (ch = "-") THEN
        sign := TRUE;
        neg := TRUE;
        Read(S, ch);
      ELSIF (ch = "+") THEN
        sign := TRUE;
        neg := FALSE;
        Read(S, ch);
      ELSE
        sign := FALSE;
        neg := FALSE;
      END;  (* IF *)
      IF ("0" <= ch) & (ch <= "9") & (S.lib IS Fonts.Font) THEN
        hex := FALSE;
        j := 0;
        LOOP
          d[i] := ch;
          INC(i, 1);
          Read(S, ch);
          IF ((ch < "0") OR ~(S.lib IS Fonts.Font)) THEN
            EXIT;
          END;  (* IF *)
          IF ("9" < ch) THEN
            IF ("A" <= ch) & (ch <= "F") THEN
              hex := TRUE;
              ch := CHR((ORD(ch) - 7));
            ELSIF ("a" <= ch) & (ch <= "f") THEN
              hex := TRUE;
              ch := CHR((ORD(ch) - 39));
            ELSE
              EXIT;
            END;  (* IF *)
          END;  (* IF *)
        END;  (* LOOP *)
        IF (ch = "H") & (S.lib IS Fonts.Font) THEN
          Read(S, ch);
          S.class := 3;
          IF ((i - j) > 8) THEN
            j := (i - 8);
          END;  (* IF *)
          k := (ORD(d[j]) - 48);
          INC(j, 1);
          IF ((i - j) = 7) & (k >= 8) THEN
            DEC(k, 16);
          END;  (* IF *)
          WHILE (j < i) DO
            k := (ASH(k, 4) + LONG((ORD(d[j]) - 48)));
            INC(j, 1);
          END;  (* WHILE *)
          IF neg THEN
            S.i := -k;
          ELSE
            S.i := k;
          END;  (* IF *)
        ELSIF (ch = ".") & (S.lib IS Fonts.Font) THEN
          Read(S, ch);
          h := i;
          WHILE ("0" <= ch) & (ch <= "9") & (S.lib IS Fonts.Font) DO
            d[i] := ch;
            INC(i, 1);
            Read(S, ch);
          END;  (* WHILE *)
          WHILE (i MOD 8 # 0) DO
            d[i] := "0";
            INC(i, 1);
          END;  (* WHILE *)
          j := 0;
          k := 0;
          k1 := 0;
          k2 := 0;
          k3 := 0;
          WHILE (j < 8) DO
            k := ((k * 10 + LONG(d[j])) - 48);
            INC(j, 1);
          END;  (* WHILE *)
          IF (8 < i) THEN
            WHILE (j < 16) DO
              k1 := ((k1 * 10 + LONG(d[j])) - 48);
              INC(j, 1);
            END;  (* WHILE *)
          END;  (* IF *)
          IF (16 < i) THEN
            WHILE (j < 24) DO
              k2 := ((k2 * 10 + LONG(d[j])) - 48);
              INC(j, 1);
            END;  (* WHILE *)
          END;  (* IF *)
          IF (24 < i) THEN
            WHILE (j < 32) DO
              k3 := ((k3 * 10 + LONG(d[j])) - 48);
              INC(j, 1);
            END;  (* WHILE *)
          END;  (* IF *)
          e := 0;
          E := ch;
          IF ((E = "D") OR (E = "E")) & (S.lib IS Fonts.Font) THEN
            Read(S, ch);
            IF (ch = "-") & (S.lib IS Fonts.Font) THEN
              negE := TRUE;
              Read(S, ch);
            ELSE
              negE := FALSE;
              IF (ch = "+") & (S.lib IS Fonts.Font) THEN
                Read(S, ch);
              END;  (* IF *)
            END;  (* IF *)
            WHILE ("0" <= ch) & (ch <= "9") & (S.lib IS Fonts.Font) DO
              e := ((e * 10 + ORD(ch)) - 48);
              Read(S, ch);
            END;  (* WHILE *)
            IF negE THEN
              e := -e;
            END;  (* IF *)
          END;  (* IF *)
          y := (k3 * Reals.Ten(-32) + k2 * Reals.Ten(-24));
          y := (y + k1 * Reals.Ten(-16));
          IF (ABS((e + LONG(h))) < 308) THEN
            y := (y + k * Reals.Ten(-8)) / Reals.Ten((-e - LONG(h)));
          ELSE
            y := (y + k * Reals.Ten(-8)) * Reals.Ten(h);
            IF ((e <= 276) OR (e <= 308) & (y < MAX(LONGREAL) / Reals.Ten(e))) THEN
              y := y * Reals.Ten(e);
            ELSE
              y := MAX(LONGREAL);
            END;  (* IF *)
          END;  (* IF *)
          IF (E = "D") THEN
            IF (y = MAX(LONGREAL)) THEN
              S.class := 0;
            ELSE
              S.class := 5;
              IF neg THEN
                S.y := -y;
              ELSE
                S.y := y;
              END;  (* IF *)
              IF (Reals.ExpoL(S.y) = 0) THEN
                S.y := 0.0;
              END;  (* IF *)
            END;  (* IF *)
          ELSIF (3.40282D+38 < y) THEN
            S.class := 0;
          ELSE
            S.class := 4;
            IF neg THEN
              S.x := SHORT(-y);
            ELSE
              S.x := SHORT(y);
            END;  (* IF *)
            IF (Reals.Expo(S.x) = 0) THEN
              S.x := 0.0;
            END;  (* IF *)
          END;  (* IF *)
          IF hex THEN
            S.class := 0;
          END;  (* IF *)
        ELSE
          S.class := 3;
          k := 0;
          WHILE (j # i) & ((k < 214748364) OR (k = 214748364) & ((ORD(d[j]) - 48) <= 7)) DO
            k := (k * 10 + LONG((ORD(d[j]) - 48)));
            INC(j, 1);
          END;  (* WHILE *)
          IF (j # i) THEN
            S.class := 0;
          ELSE
            IF neg THEN
              S.i := -k;
            ELSE
              S.i := k;
            END;  (* IF *)
            IF hex THEN
              S.class := 0;
            ELSE
              S.class := 3;
            END;  (* IF *)
          END;  (* IF *)
        END;  (* IF *)
      ELSE
        S.class := 6;
        IF sign THEN
          IF neg THEN
            S.c := "-";
          ELSE
            S.c := "+";
          END;  (* IF *)
        ELSE
          S.c := ch;
          Read(S, ch);
        END;  (* IF *)
      END;  (* IF *)
    END;  (* IF *)
    S.nextCh := ch;
  END Scan;


  PROCEDURE SetColor*(VAR W: Writer; col: SHORTINT);

  BEGIN  (* PROCEDURE SetColor *)
    W.col := col;
  END SetColor;


  PROCEDURE SetFont*(VAR W: Writer; fnt: Objects.Library);

  BEGIN  (* PROCEDURE SetFont *)
    W.lib := fnt;
  END SetFont;


  PROCEDURE SetOffset*(VAR W: Writer; voff: SHORTINT);

  BEGIN  (* PROCEDURE SetOffset *)
    W.voff := voff;
  END SetOffset;


  PROCEDURE Store*(T: Text; f: Files.File; pos: LONGINT; VAR len: LONGINT);

    TYPE
      ARRAYBCC = ARRAY 256 OF Objects.Object;
      ObjsBlock = POINTER TO ObjsBlockDesc;
      ObjsBlockDesc = RECORD
        VARBD2: ARRAYBCC;
        VARBD4: ObjsBlock;
      END;
      ARRAYC2C = ARRAY 32 OF Objects.Name;

    VAR
      type: CHAR;
      rlen: LONGINT;
      q: Piece;
      p: Piece;
      objs: ObjsBlock;
      obj: Objects.Object;
      n: SHORTINT;
      m: LONGINT;
      id: INTEGER;
      i: INTEGER;
      hlen: LONGINT;
      flen: LONGINT;
      curObjs: ObjsBlock;
      ch: CHAR;
      allObjs: ObjsBlock;
      W: Files.Rider;
      R: Files.Rider;
      N: SHORTINT;
      M: Objects.BindMsg;
      Dict: ARRAYC2C;

  BEGIN  (* PROCEDURE Store *)
    Files.Set(W, f, pos);
    Files.Write(W, TextBlockId);
    Files.Write(W, type);
    Files.WriteLInt(W, hlen);
    Dict[0][0] := 000X;
    N := 1;
    p := T.VAR242.VARDE;
    WHILE (p # T.VAR242) DO
      rlen := p.VARC3;
      q := p.VARDE;
      IF (p.VARD4 IS Fonts.Font) THEN
        WHILE (q # T.VAR242) & (q.VARD4 = p.VARD4) & (q.VARD8 = p.VARD8) & (q.VARDA = p.VARDA) DO
          rlen := (rlen + q.VARC3);
          q := q.VARDE;
        END;  (* WHILE *)
      END;  (* IF *)
      Dict[N] := p.VARD4.name;
      n := 0;
      WHILE (Dict[n] # p.VARD4.name) DO
        INC(n, 1);
      END;  (* WHILE *)
      Files.Write(W, n);
      IF (n = N) THEN
        Files.WriteString(W, p.VARD4.name);
        INC(N, 1);
      END;  (* IF *)
      Files.Write(W, p.VARD8);
      Files.Write(W, p.VARDA);
      Files.WriteLInt(W, rlen);
      p := q;
    END;  (* WHILE *)
    Files.Write(W, 0);
    Files.WriteLInt(W, T.len);
    NEW(allObjs);
    allObjs.VARBD4 := NIL;
    curObjs := allObjs;
    hlen := (Files.Pos(W) - pos);
    id := 0;
    p := T.VAR242.VARDE;
    WHILE (p # T.VAR242) DO
      Files.Set(R, p.VARBF, p.VARC1);
      m := p.VARC3;
      WHILE (m # 0) DO
        Files.Read(R, ch);
        IF (p.VARD4.name[0] = 000X) THEN
          p.VARD4.GetObj(p.VARD4, ORD(ch), obj);
          p.VARCB := obj;
          IF (obj # NIL) THEN
            curObjs.VARBD2[id MOD 256] := obj;
            i := 0;
            objs := allObjs;
            WHILE (objs.VARBD2[i MOD 256] # obj) DO
              INC(i, 1);
              IF (i MOD 256 = 0) THEN
                objs := objs.VARBD4;
              END;  (* IF *)
            END;  (* WHILE *)
            IF (i = id) THEN
              INC(id, 1);
              IF (id MOD 256 = 0) THEN
                NEW(curObjs.VARBD4);
                p.VARD6 := id;
                curObjs := curObjs.VARBD4;
                curObjs.VARBD4 := NIL;
              END;  (* IF *)
            END;  (* IF *)
            ch := CHR(i MOD 256);
          ELSE
            ch := 000X;
          END;  (* IF *)
        END;  (* IF *)
        Files.Write(W, ch);
        DEC(m, 1);
      END;  (* WHILE *)
      p := p.VARDE;
    END;  (* WHILE *)
    IF (id > 0) THEN
      IF (id > 255) THEN
        type := NoSpex2;
      ELSE
        type := NoSpex;
      END;  (* IF *)
      NEW(T.VAR240);
      Objects.OpenLibrary(T.VAR240);
      i := 0;
      objs := allObjs;
      REPEAT
        T.VAR240.PutObj(T.VAR240, i, objs.VARBD2[i MOD 256]);
        INC(i, 1);
        IF (i MOD 256 = 0) THEN
          objs := objs.VARBD4;
        END;  (* IF *)
      UNTIL (i = id);
      M.lib := T.VAR240;
      i := 0;
      objs := allObjs;
      REPEAT
        objs.VARBD2[i MOD 256].handle(objs.VARBD2[i MOD 256], M);
        INC(i, 1);
        IF (i MOD 256 = 0) THEN
          objs := objs.VARBD4;
        END;  (* IF *)
      UNTIL (i = id);
      Objects.StoreLibrary(T.VAR240, f, ((pos + hlen) + T.len), flen);
      IF (type = NoSpex2) THEN
        Files.Set(W, f, (((pos + hlen) + T.len) + flen));
        p := T.VAR242.VARDE;
        WHILE (p # T.VAR242) DO
          IF (p.VARD4.name[0] = 000X) THEN
            i := 0;
            objs := allObjs;
            WHILE (objs.VARBD2[i MOD 256] # p.VARCB) DO
              INC(i, 1);
              IF (i MOD 256 = 0) THEN
                objs := objs.VARBD4;
              END;  (* IF *)
            END;  (* WHILE *)
            Files.WriteInt(W, i);
            INC(flen, 2);
          END;  (* IF *)
          p := p.VARDE;
        END;  (* WHILE *)
      END;  (* IF *)
    ELSE
      type := TextSpex;
      flen := 0;
    END;  (* IF *)
    Files.Set(W, f, pos + 1);
    Files.Write(W, type);
    Files.WriteLInt(W, hlen);
    len := ((hlen + T.len) + flen);
  END Store;


  PROCEDURE Write*(VAR W: Writer; ch: CHAR);

    VAR
      q: Piece;
      p: Piece;

  BEGIN  (* PROCEDURE Write *)
    p := W.buf.VARE7;
    IF ((((~(W.lib IS Fonts.Font) OR (W.lib # p.VARD4)) OR (W.col # p.VARD8)) OR (W.voff # p.VARDA)) OR (Files.Base(W.VAR9D) # p.VARBF)) THEN
      NEW(q);
      q.VARD6 := -32768;
      IF ~(W.lib IS Fonts.Font) THEN
        W.lib.GetObj(W.lib, ORD(ch), q.VARCB);
      END;  (* IF *)
      q.VARBF := Files.Base(W.VAR9D);
      q.VARC1 := Files.Pos(W.VAR9D);
      q.VARC3 := 0;
      q.VARD4 := W.lib;
      q.VARD8 := W.col;
      q.VARDA := W.voff;
      q.VARDE := NIL;
      p.VARDE := q;
      q.VARDC := p;
      p := q;
      W.buf.VARE7 := p;
    END;  (* IF *)
    Files.Write(W.VAR9D, ch);
    INC(p.VARC3, 1);
    INC(W.buf.len, 1);
  END Write;


  PROCEDURE WriteDate*(VAR W: Writer; t: LONGINT; d: LONGINT);


    PROCEDURE WritePair(ch: CHAR; x: LONGINT);

    BEGIN  (* PROCEDURE WritePair *)
      Write(W, ch);
      Write(W, CHR((x DIV 10 + 48)));
      Write(W, CHR((x MOD 10 + 48)));
    END WritePair;


  BEGIN  (* PROCEDURE WriteDate *)
    WritePair(" ", d MOD 32);
    WritePair(".", ASH(d, -5) MOD 16);
    WritePair(".", ASH(d, -9) MOD 128);
    WritePair(" ", ASH(t, -12) MOD 32);
    WritePair(":", ASH(t, -6) MOD 64);
    WritePair(":", t MOD 64);
  END WriteDate;


  PROCEDURE WriteHex*(VAR W: Writer; x: LONGINT);

    TYPE
      ARRAY1C4B = ARRAY 10 OF CHAR;

    VAR
      y: LONGINT;
      i: INTEGER;
      a: ARRAY1C4B;

  BEGIN  (* PROCEDURE WriteHex *)
    i := 0;
    Write(W, " ");
    REPEAT
      y := x MOD 16;
      IF (y < 10) THEN
        a[i] := CHR((y + 48));
      ELSE
        a[i] := CHR((y + 55));
      END;  (* IF *)
      x := ASH(x, -4);
      INC(i, 1);
    UNTIL (i = 8);
    REPEAT
      DEC(i, 1);
      Write(W, a[i]);
    UNTIL (i = 0);
  END WriteHex;


  PROCEDURE WriteInt*(VAR W: Writer; x: LONGINT; n: LONGINT);

    TYPE
      ARRAY1BD2 = ARRAY 10 OF CHAR;

    VAR
      x0: LONGINT;
      i: INTEGER;
      a: ARRAY1BD2;

  BEGIN  (* PROCEDURE WriteInt *)
    i := 0;
    IF (x < 0) THEN
      IF (x = MIN(LONGINT)) THEN
        WriteString(W, " -2147483648");
        RETURN;
      ELSE
        DEC(n, 1);
        x0 := -x;
      END;  (* IF *)
    ELSE
      x0 := x;
    END;  (* IF *)
    REPEAT
      a[i] := CHR((x0 MOD 10 + 48));
      x0 := x0 DIV 10;
      INC(i, 1);
    UNTIL (x0 = 0);
    WHILE (n > LONG(i)) DO
      Write(W, " ");
      DEC(n, 1);
    END;  (* WHILE *)
    IF (x < 0) THEN
      Write(W, "-");
    END;  (* IF *)
    REPEAT
      DEC(i, 1);
      Write(W, a[i]);
    UNTIL (i = 0);
  END WriteInt;


  PROCEDURE WriteLn*(VAR W: Writer);

  BEGIN  (* PROCEDURE WriteLn *)
    Write(W, 00DX);
  END WriteLn;


  PROCEDURE WriteLongReal*(VAR W: Writer; x: LONGREAL; n: LONGINT);

    TYPE
      ARRAY1FC1 = ARRAY 16 OF CHAR;

    VAR
      z: LONGREAL;
      l: LONGINT;
      i: LONGINT;
      h: LONGINT;
      e: LONGINT;
      d: ARRAY1FC1;

  BEGIN  (* PROCEDURE WriteLongReal *)
    e := Reals.ExpoL(x);
    IF (e = 2047) THEN
      WHILE (n > 9) DO
        Write(W, " ");
        DEC(n, 1);
      END;  (* WHILE *)
      WriteString(W, "      NaN");
    ELSE
      IF (n <= 9) THEN
        n := 1;
      ELSE
        DEC(n, 8);
      END;  (* IF *)
      REPEAT
        Write(W, " ");
        DEC(n, 1);
      UNTIL (n <= 15);
      IF (e # 0) & (x < 0.0) THEN
        Write(W, "-");
        x := -x;
      ELSE
        Write(W, " ");
      END;  (* IF *)
      IF (e = 0) THEN
        h := 0;
        l := 0;
      ELSE
        e := (e - 1023) * 301029 DIV 1000000;
        z := Reals.Ten(e + 1);
        IF (x >= z) THEN
          x := x / z;
          INC(e, 1);
        ELSE
          x := x * Reals.Ten(-e);
        END;  (* IF *)
        IF (x >= 10.0) THEN
          x := (x * Reals.Ten(-1) + 0.5 / Reals.Ten(n));
          INC(e, 1);
        ELSE
          x := (x + 0.5 / Reals.Ten(n));
          IF (x >= 10.0) THEN
            x := x * Reals.Ten(-1);
            INC(e, 1);
          END;  (* IF *)
        END;  (* IF *)
        x := x * Reals.Ten(7);
        h := ENTIER(x);
        x := (x - h) * Reals.Ten(8);
        l := ENTIER(x);
      END;  (* IF *)
      i := 15;
      WHILE (i > 7) DO
        d[i] := CHR((l MOD 10 + 48));
        l := l DIV 10;
        DEC(i, 1);
      END;  (* WHILE *)
      WHILE (i >= 0) DO
        d[i] := CHR((h MOD 10 + 48));
        h := h DIV 10;
        DEC(i, 1);
      END;  (* WHILE *)
      Write(W, d[0]);
      Write(W, ".");
      i := 1;
      WHILE (i <= n) DO
        Write(W, d[i]);
        INC(i, 1);
      END;  (* WHILE *)
      IF (e < 0) THEN
        WriteString(W, "D-");
        e := -e;
      ELSE
        WriteString(W, "D+");
      END;  (* IF *)
      Write(W, CHR((e DIV 100 + 48)));
      e := e MOD 100;
      Write(W, CHR((e DIV 10 + 48)));
      Write(W, CHR((e MOD 10 + 48)));
    END;  (* IF *)
  END WriteLongReal;


  PROCEDURE WriteLongRealFix*(VAR W: Writer; x: LONGREAL; n: LONGINT; f: LONGINT; D: LONGINT);

    TYPE
      ARRAY211F = ARRAY 16 OF CHAR;

    VAR
      z: LONGREAL;
      s: CHAR;
      r: LONGREAL;
      l: LONGINT;
      i: LONGINT;
      h: LONGINT;
      e: LONGINT;
      d: ARRAY211F;

  BEGIN  (* PROCEDURE WriteLongRealFix *)
    e := Reals.ExpoL(x);
    IF ((e = 2047) OR (ABS(D) > 308)) THEN
      WHILE (n > 9) DO
        Write(W, " ");
        DEC(n, 1);
      END;  (* WHILE *)
      WriteString(W, "      NaN");
    ELSE
      IF (D = 0) THEN
        DEC(n, 2);
      ELSE
        DEC(n, 7);
      END;  (* IF *)
      IF (n < 2) THEN
        n := 2;
      END;  (* IF *)
      IF (f < 0) THEN
        f := 0;
      END;  (* IF *)
      IF (n < (f + 2)) THEN
        n := (f + 2);
      END;  (* IF *)
      DEC(n, f);
      IF (e # 0) & (x < 0.0) THEN
        s := "-";
        x := -x;
      ELSE
        s := " ";
      END;  (* IF *)
      IF (e = 0) THEN
        h := 0;
        l := 0;
        DEC(e, (D - 1));
      ELSE
        e := (e - 1023) * 301029 DIV 1000000;
        z := Reals.Ten(e + 1);
        IF (x >= z) THEN
          x := x / z;
          INC(e, 1);
        ELSE
          x := x * Reals.Ten(-e);
        END;  (* IF *)
        DEC(e, (D - 1));
        i := -(e + f);
        IF (i <= 0) THEN
          r := 5.0 * Reals.Ten(i);
        ELSE
          r := 0.0;
        END;  (* IF *)
        IF (x >= 10.0) THEN
          x := (x * Reals.Ten(-1) + r);
          INC(e, 1);
        ELSE
          x := (x + r);
          IF (x >= 10.0) THEN
            x := x * Reals.Ten(-1);
            INC(e, 1);
          END;  (* IF *)
        END;  (* IF *)
        x := x * Reals.Ten(7);
        h := ENTIER(x);
        x := (x - h) * Reals.Ten(8);
        l := ENTIER(x);
      END;  (* IF *)
      i := 15;
      WHILE (i > 7) DO
        d[i] := CHR((l MOD 10 + 48));
        l := l DIV 10;
        DEC(i, 1);
      END;  (* WHILE *)
      WHILE (i >= 0) DO
        d[i] := CHR((h MOD 10 + 48));
        h := h DIV 10;
        DEC(i, 1);
      END;  (* WHILE *)
      IF (n <= e) THEN
        n := (e + 1);
      END;  (* IF *)
      IF (e > 0) THEN
        WHILE (n > e) DO
          Write(W, " ");
          DEC(n, 1);
        END;  (* WHILE *)
        Write(W, s);
        e := 0;
        WHILE (n > 0) DO
          DEC(n, 1);
          IF (e < 16) THEN
            Write(W, d[e]);
            INC(e, 1);
          ELSE
            Write(W, "0");
          END;  (* IF *)
        END;  (* WHILE *)
        Write(W, ".");
      ELSE
        WHILE (n > 1) DO
          Write(W, " ");
          DEC(n, 1);
        END;  (* WHILE *)
        Write(W, s);
        Write(W, "0");
        Write(W, ".");
        WHILE (0 < f) & (e < 0) DO
          Write(W, "0");
          DEC(f, 1);
          INC(e, 1);
        END;  (* WHILE *)
      END;  (* IF *)
      WHILE (f > 0) DO
        DEC(f, 1);
        IF (e < 16) THEN
          Write(W, d[e]);
          INC(e, 1);
        ELSE
          Write(W, "0");
        END;  (* IF *)
      END;  (* WHILE *)
      IF (D # 0) THEN
        IF (D < 0) THEN
          WriteString(W, "D-");
          D := -D;
        ELSE
          WriteString(W, "D+");
        END;  (* IF *)
        Write(W, CHR((D DIV 100 + 48)));
        D := D MOD 100;
        Write(W, CHR((D DIV 10 + 48)));
        Write(W, CHR((D MOD 10 + 48)));
      END;  (* IF *)
    END;  (* IF *)
  END WriteLongRealFix;


  PROCEDURE WriteLongRealHex*(VAR W: Writer; x: LONGREAL);

    VAR
      l: LONGINT;
      h: LONGINT;

  BEGIN  (* PROCEDURE WriteLongRealHex *)
    Reals.IntL(x, h, l);
    WriteHex(W, h);
    WriteHex(W, l);
  END WriteLongRealHex;


  PROCEDURE WriteObj*(VAR W: Writer; obj: Objects.Object);

    VAR
      lib: Objects.Library;

  BEGIN  (* PROCEDURE WriteObj *)
    IF (((obj.lib = NIL) OR (obj.ref < 0)) OR (obj.lib.name[0] = 000X)) THEN
      IF (obs = NIL) THEN
        NEW(obs);
        Objects.OpenLibrary(obs);
      END;  (* IF *)
      obs.GenRef(obs, obj.ref);
      IF (obj.ref >= 256) THEN
        NEW(obs);
        Objects.OpenLibrary(obs);
        obs.GenRef(obs, obj.ref);
      END;  (* IF *)
      obs.PutObj(obs, obj.ref, obj);
    END;  (* IF *)
    ASSERT((obj.ref < 256));
    lib := W.lib;
    SetFont(W, obj.lib);
    Write(W, CHR(obj.ref));
    SetFont(W, lib);
  END WriteObj;


  PROCEDURE WriteReal*(VAR W: Writer; x: REAL; n: LONGINT);

    TYPE
      ARRAY1CC4 = ARRAY 8 OF CHAR;

    VAR
      z: REAL;
      y: LONGREAL;
      i: LONGINT;
      h: LONGINT;
      e: LONGINT;
      d: ARRAY1CC4;

  BEGIN  (* PROCEDURE WriteReal *)
    e := Reals.Expo(x);
    IF (e = 255) THEN
      WHILE (n > 8) DO
        Write(W, " ");
        DEC(n, 1);
      END;  (* WHILE *)
      WriteString(W, "     NaN");
    ELSE
      IF (n <= 8) THEN
        n := 1;
      ELSE
        DEC(n, 7);
      END;  (* IF *)
      REPEAT
        Write(W, " ");
        DEC(n, 1);
      UNTIL (n <= 7);
      IF (e # 0) & (x < 0.0) THEN
        Write(W, "-");
        x := -x;
      ELSE
        Write(W, " ");
      END;  (* IF *)
      IF (e = 0) THEN
        h := 0;
      ELSE
        e := (e - 127) * 301 DIV 1000;
        IF (e < 38) THEN
          z := SHORT(Reals.Ten(e + 1));
          IF (x >= z) THEN
            y := LONG(x) / LONG(z);
            INC(e, 1);
          ELSE
            y := LONG(x) * Reals.Ten(-e);
          END;  (* IF *)
        ELSE
          y := LONG(x) * Reals.Ten(-38);
        END;  (* IF *)
        IF (y >= 10.0) THEN
          y := (y * Reals.Ten(-1) + 0.5 / Reals.Ten(n));
          INC(e, 1);
        ELSE
          y := (y + 0.5 / Reals.Ten(n));
          IF (y >= 10.0) THEN
            y := y * Reals.Ten(-1);
            INC(e, 1);
          END;  (* IF *)
        END;  (* IF *)
        y := y * Reals.Ten(7);
        h := ENTIER(y);
      END;  (* IF *)
      i := 7;
      WHILE (i >= 0) DO
        d[i] := CHR((h MOD 10 + 48));
        h := h DIV 10;
        DEC(i, 1);
      END;  (* WHILE *)
      Write(W, d[0]);
      Write(W, ".");
      i := 1;
      WHILE (i <= n) DO
        Write(W, d[i]);
        INC(i, 1);
      END;  (* WHILE *)
      IF (e < 0) THEN
        WriteString(W, "E-");
        e := -e;
      ELSE
        WriteString(W, "E+");
      END;  (* IF *)
      Write(W, CHR((e DIV 10 + 48)));
      Write(W, CHR((e MOD 10 + 48)));
    END;  (* IF *)
  END WriteReal;


  PROCEDURE WriteRealFix*(VAR W: Writer; x: REAL; n: LONGINT; f: LONGINT; E: LONGINT);

    TYPE
      ARRAY1E0E = ARRAY 8 OF CHAR;

    VAR
      z: REAL;
      y: LONGREAL;
      s: CHAR;
      r: LONGREAL;
      i: LONGINT;
      h: LONGINT;
      e: LONGINT;
      d: ARRAY1E0E;

  BEGIN  (* PROCEDURE WriteRealFix *)
    e := Reals.Expo(x);
    IF ((e = 255) OR (ABS(E) > 38)) THEN
      WHILE (n > 8) DO
        Write(W, " ");
        DEC(n, 1);
      END;  (* WHILE *)
      WriteString(W, "     NaN");
    ELSE
      IF (E = 0) THEN
        DEC(n, 2);
      ELSE
        DEC(n, 6);
      END;  (* IF *)
      IF (f < 0) THEN
        f := 0;
      END;  (* IF *)
      IF (n < (f + 2)) THEN
        n := (f + 2);
      END;  (* IF *)
      DEC(n, f);
      IF (e # 0) & (x < 0.0) THEN
        s := "-";
        x := -x;
      ELSE
        s := " ";
      END;  (* IF *)
      IF (e = 0) THEN
        h := 0;
        DEC(e, (E - 1));
      ELSE
        e := (e - 127) * 301 DIV 1000;
        IF (e < 38) THEN
          z := SHORT(Reals.Ten(e + 1));
          IF (x >= z) THEN
            y := LONG(x) / LONG(z);
            INC(e, 1);
          ELSE
            y := LONG(x) * Reals.Ten(-e);
          END;  (* IF *)
        ELSE
          y := LONG(x) * Reals.Ten(-38);
        END;  (* IF *)
        DEC(e, (E - 1));
        i := -(e + f);
        IF (i <= 0) THEN
          r := 5.0 * Reals.Ten(i);
        ELSE
          r := 0.0;
        END;  (* IF *)
        IF (y >= 10.0) THEN
          y := (y * Reals.Ten(-1) + r);
          INC(e, 1);
        ELSE
          y := (y + r);
          IF (y >= 10.0) THEN
            y := y * Reals.Ten(-1);
            INC(e, 1);
          END;  (* IF *)
        END;  (* IF *)
        y := y * Reals.Ten(7);
        h := ENTIER(y);
      END;  (* IF *)
      i := 7;
      WHILE (i >= 0) DO
        d[i] := CHR((h MOD 10 + 48));
        h := h DIV 10;
        DEC(i, 1);
      END;  (* WHILE *)
      IF (n <= e) THEN
        n := (e + 1);
      END;  (* IF *)
      IF (e > 0) THEN
        WHILE (n > e) DO
          Write(W, " ");
          DEC(n, 1);
        END;  (* WHILE *)
        Write(W, s);
        e := 0;
        WHILE (n > 0) DO
          DEC(n, 1);
          IF (e < 8) THEN
            Write(W, d[e]);
            INC(e, 1);
          ELSE
            Write(W, "0");
          END;  (* IF *)
        END;  (* WHILE *)
        Write(W, ".");
      ELSE
        WHILE (n > 1) DO
          Write(W, " ");
          DEC(n, 1);
        END;  (* WHILE *)
        Write(W, s);
        Write(W, "0");
        Write(W, ".");
        WHILE (0 < f) & (e < 0) DO
          Write(W, "0");
          DEC(f, 1);
          INC(e, 1);
        END;  (* WHILE *)
      END;  (* IF *)
      WHILE (f > 0) DO
        DEC(f, 1);
        IF (e < 8) THEN
          Write(W, d[e]);
          INC(e, 1);
        ELSE
          Write(W, "0");
        END;  (* IF *)
      END;  (* WHILE *)
      IF (E # 0) THEN
        IF (E < 0) THEN
          WriteString(W, "E-");
          E := -E;
        ELSE
          WriteString(W, "E+");
        END;  (* IF *)
        Write(W, CHR((E DIV 10 + 48)));
        Write(W, CHR((E MOD 10 + 48)));
      END;  (* IF *)
    END;  (* IF *)
  END WriteRealFix;


  PROCEDURE WriteRealHex*(VAR W: Writer; x: REAL);

  BEGIN  (* PROCEDURE WriteRealHex *)
    WriteHex(W, Reals.Int(x));
  END WriteRealHex;


  PROCEDURE WriteSet*(VAR W: Writer; s: SET);

    VAR
      last: LONGINT;
      i: LONGINT;
      dots: BOOLEAN;

  BEGIN  (* PROCEDURE WriteSet *)
    Write(W, "{");
    last := MIN(LONGINT);
    i := 0;
    WHILE (i <= 31) DO
      IF (i IN s) THEN
        IF (last = (i - 1)) THEN
          IF dots THEN
            WriteString(W, " .. ");
            dots := FALSE;
          END;  (* IF *)
          IF ((i = 31) OR ~((i + 1) IN s)) THEN
            WriteInt(W, i, 0);
          END;  (* IF *)
        ELSE
          IF (last >= 0) THEN
            WriteString(W, ", ");
          END;  (* IF *)
          WriteInt(W, i, 0);
          dots := TRUE;
        END;  (* IF *)
        last := i;
      END;  (* IF *)
      INC(i, 1);
    END;  (* WHILE *)
    Write(W, "}");
  END WriteSet;


  PROCEDURE WriteString*(VAR W: Writer; s: ARRAY105);

    VAR
      i: INTEGER;

  BEGIN  (* PROCEDURE WriteString *)
    i := 0;
    WHILE (s[i] # 000X) DO
      Write(W, s[i]);
      INC(i, 1);
    END;  (* WHILE *)
  END WriteString;


BEGIN  (* MODULE Texts *)
  TextBlockId := 0F0X;
  DocBlockId := 0F7X;
  NoSpex := 000X;
  TextSpex := 001X;
  NoSpex2 := 002X;
  H := (Handle);
  Wfile := Files.New("");
  Files.Set(R, Wfile, 0);
  Files.Write(R, 000X);
  NEW(DelBuf);
  OpenBuf(DelBuf);
  InitScan();
  obs := NIL;
END Texts.
