(***************************************************************************

   Input File:   EDIT.OBJ
   Date/Time:    Mon Jan 11 18:17:59 2021
   -------------------------------------------------------

   Generated by Slim Binary(tm) Decoder Version 2.00

 ***************************************************************************)

MODULE Edit;    (* Slim Binary(tm) *)

  IMPORT
    Files, Objects, Display, Viewers, MenuViewers, Printer, Fonts, Texts, TextFrames, Oberon;

  CONST
    BufLen = 64;
    CR = 00DX;
    ErrorsText = "OberonErrors.Text";
    MaxPatLen = 128;
    StandardMenu = "System.Close System.Copy System.Grow Edit.Search Edit.Replace Edit.Store";
    maxlen = 32;

  TYPE
    ARRAY19B = ARRAY 128 OF CHAR;
    ARRAY1A4 = ARRAY 129 OF INTEGER;
    ARRAY1B7 = ARRAY 32 OF CHAR;
    ARRAY1D4 = ARRAY 256 OF INTEGER;
    ARRAY283 = ARRAY 64 OF CHAR;
    BackRdr* = RECORD
      VAR281: Texts.Text;
      VAR287: ARRAY283;
      VAR289: LONGINT;
      VAR28B: INTEGER;
      VAR28D: INTEGER;
      VAR28F: BOOLEAN;
    END;

  VAR
    topY: INTEGER;
    time: LONGINT;
    textX: INTEGER;
    sPatLen: INTEGER;
    sPat: ARRAY19B;
    sDv: ARRAY1A4;
    rBuf: Texts.Buffer;
    pat: ARRAY1B7;
    pagenoX: INTEGER;
    lTime: LONGINT;
    headerY: INTEGER;
    d: ARRAY1D4;
    botY: INTEGER;
    W: Texts.Writer;
    M: INTEGER;

  (* Forward PROCEDURE declarations *)

  PROCEDURE^ Handler(F: Objects.Object; VAR M: Objects.ObjMsg);
  PROCEDURE^ BackRead(VAR bR: BackRdr; VAR ch: CHAR);
  PROCEDURE^ CalcDispVec(time: LONGINT);
  PROCEDURE^ GetPageSize();
  PROCEDURE^ GetText(VAR par: Display.Frame): Texts.Text;
  PROCEDURE^ InitPattern();
  PROCEDURE^ LinesOf(tF: TextFrames.Frame): INTEGER;
  PROCEDURE^ LinesUp(text: Texts.Text; pos: LONGINT; nbr: INTEGER): LONGINT;
  PROCEDURE^ MarkMenu(F: TextFrames.Frame; updT: Texts.Text);
  PROCEDURE^ MarkPatPos(tF: TextFrames.Frame; pos: LONGINT);
  PROCEDURE^ Max(i: LONGINT; j: LONGINT): LONGINT;
  PROCEDURE^ OpenBackRdr(VAR bR: BackRdr; text: Texts.Text; pos: LONGINT);
  PROCEDURE^ RPos(VAR bR: BackRdr): LONGINT;
  PROCEDURE^ RemoveMarks(tF: TextFrames.Frame);
  PROCEDURE^ SPatFound(tF: TextFrames.Frame; text: Texts.Text; VAR pos: LONGINT): BOOLEAN;
  PROCEDURE^ SetCaret(F: Display.Frame; T: Texts.Text; pos: LONGINT);
  PROCEDURE^ ThisFrame(X: INTEGER; Y: INTEGER; VAR F: Display.Frame);
  PROCEDURE^ UnMarkMenu(F: TextFrames.Frame);
  PROCEDURE^ replace(): BOOLEAN;
  PROCEDURE^ ChangeColor*();
  PROCEDURE^ ChangeFont*();
  PROCEDURE^ Clear*();
  PROCEDURE^ CopyFont*();
  PROCEDURE^ Error*();
  PROCEDURE^ Locate*();
  PROCEDURE^ Open*();
  PROCEDURE^ Print*();
  PROCEDURE^ Recall*();
  PROCEDURE^ Replace*();
  PROCEDURE^ ReplaceAll*();
  PROCEDURE^ Search*();
  PROCEDURE^ Show*();
  PROCEDURE^ Store*();

  PROCEDURE Handler(F: Objects.Object; VAR M: Objects.ObjMsg);

  BEGIN  (* PROCEDURE Handler *)
    WITH F: TextFrames.Frame DO
      IF (M IS Texts.UpdateMsg) THEN
        WITH M: Texts.UpdateMsg DO
          IF (M.text = F^.text) THEN
            MarkMenu(F, F^.text);
          END;  (* IF *)
        END;  (* WITH *)
      END;  (* IF *)
      TextFrames.Handle(F, M);
    END;  (* WITH *)
  END Handler;


  PROCEDURE BackRead(VAR bR: BackRdr; VAR ch: CHAR);

  BEGIN  (* PROCEDURE BackRead *)
    IF (bR.VAR28D >= bR.VAR28B) THEN
      ch := bR.VAR287[bR.VAR28D];
      DEC(bR.VAR28D, 1);
      bR.VAR28F := FALSE;
    ELSIF (bR.VAR28D = -1) & (bR.VAR289 > 0) THEN
      OpenBackRdr(bR, bR.VAR281, bR.VAR289);
      BackRead(bR, ch);
    ELSE
      ch := 000X;
      bR.VAR28F := TRUE;
    END;  (* IF *)
  END BackRead;


  PROCEDURE CalcDispVec(time: LONGINT);

    VAR
      j: INTEGER;
      i: INTEGER;
      d: INTEGER;

  BEGIN  (* PROCEDURE CalcDispVec *)
    lTime := time;
    i := 1;
    d := 1;
    WHILE (i <= sPatLen) DO
      j := 0;
      WHILE ((j + d) < sPatLen) & (sPat[j] = sPat[(j + d)]) DO
        INC(j, 1);
      END;  (* WHILE *)
      WHILE (i <= (j + d)) DO
        sDv[i] := d;
        INC(i, 1);
      END;  (* WHILE *)
      INC(d, 1);
    END;  (* WHILE *)
  END CalcDispVec;


  PROCEDURE GetPageSize();

  BEGIN  (* PROCEDURE GetPageSize *)
    textX := Printer.FrameX;
    pagenoX := (textX + Printer.FrameW * 19 DIV 20);
    botY := Printer.FrameY;
    headerY := ((botY + Printer.FrameH) - Fonts.Default^.height);
    topY := (headerY - 3 * Fonts.Default^.height);
  END GetPageSize;


  PROCEDURE GetText(VAR par: Display.Frame): Texts.Text;

    VAR
      t: Texts.Text;
      M: Objects.LinkMsg;

  BEGIN  (* PROCEDURE GetText *)
    t := NIL;
    ThisFrame(Oberon.Pointer.X, Oberon.Pointer.Y, par);
    IF (par # NIL) THEN
      M.id := 1;
      M.name := "Model";
      M.obj := NIL;
      M.res := -1;
      par^.handle(par, M);
      IF (M.obj # NIL) & (M.obj IS Texts.Text) THEN
        t := M.obj(Texts.Text);
      END;  (* IF *)
    END;  (* IF *)
    RETURN t;
  END GetText;


  PROCEDURE InitPattern();

    VAR
      j: INTEGER;

  BEGIN  (* PROCEDURE InitPattern *)
    pat[0] := " ";
    M := 1;
    time := -1;
    j := 0;
    WHILE (j # 256) DO
      d[j] := M;
      INC(j, 1);
    END;  (* WHILE *)
  END InitPattern;


  PROCEDURE LinesOf(tF: TextFrames.Frame): INTEGER;

  BEGIN  (* PROCEDURE LinesOf *)
    RETURN ((tF^.H - tF^.top) - tF^.bot) DIV tF^.lsp;
  END LinesOf;


  PROCEDURE LinesUp(text: Texts.Text; pos: LONGINT; nbr: INTEGER): LONGINT;

    VAR
      l: INTEGER;
      ch: CHAR;
      bR: BackRdr;

  BEGIN  (* PROCEDURE LinesUp *)
    OpenBackRdr(bR, text, pos);
    l := 0;
    REPEAT
      BackRead(bR, ch);
      IF (ch = 00DX) THEN
        INC(l, 1);
      END;  (* IF *)
    UNTIL (bR.VAR28F OR (l > nbr));
    pos := RPos(bR);
    IF ~bR.VAR28F THEN
      INC(pos, 1);
    END;  (* IF *)
    RETURN pos;
  END LinesUp;


  PROCEDURE MarkMenu(F: TextFrames.Frame; updT: Texts.Text);

    VAR
      ch: CHAR;
      V: Viewers.Viewer;
      T: Texts.Text;
      R: Texts.Reader;

  BEGIN  (* PROCEDURE MarkMenu *)
    V := Viewers.This(F^.X, F^.Y);
    IF (V IS MenuViewers.Viewer) & (V^.dsc IS TextFrames.Frame) THEN
      T := V^.dsc(TextFrames.Frame)^.text;
      IF (T # updT) THEN
        IF (T^.len > 0) THEN
          Texts.OpenReader(R, T, T^.len - 1);
          Texts.Read(R, ch);
        ELSE
          ch := 000X;
        END;  (* IF *)
        IF (ch # "!") THEN
          Texts.WriteString(W, " !");
          Texts.Append(T, W.buf);
        END;  (* IF *)
      END;  (* IF *)
    END;  (* IF *)
  END MarkMenu;


  PROCEDURE MarkPatPos(tF: TextFrames.Frame; pos: LONGINT);

    VAR
      l: LONGINT;

  BEGIN  (* PROCEDURE MarkPatPos *)
    RemoveMarks(tF);
    IF ((pos < TextFrames.Pos(tF, tF^.X, tF^.Y + tF^.H)) OR (TextFrames.Pos(tF, tF^.X + tF^.W, tF^.Y) < pos)) THEN
      l := LinesOf(tF);
      IF (l > 4) THEN
        l := LinesUp(tF^.text, pos, 4);
      ELSE
        l := LinesUp(tF^.text, pos, 1);
      END;  (* IF *)
      TextFrames.Show(tF, l);
    END;  (* IF *)
    Oberon.Defocus();
    TextFrames.SetCaret(tF, pos);
    TextFrames.SetSelection(tF, (pos - LONG(sPatLen)), pos);
    lTime := tF^.time;
  END MarkPatPos;


  PROCEDURE Max(i: LONGINT; j: LONGINT): LONGINT;

  BEGIN  (* PROCEDURE Max *)
    IF (i >= j) THEN
      RETURN i;
    ELSE
      RETURN j;
    END;  (* IF *)
  END Max;


  PROCEDURE OpenBackRdr(VAR bR: BackRdr; text: Texts.Text; pos: LONGINT);

    VAR
      i: INTEGER;
      ch: CHAR;
      R: Texts.Reader;

  BEGIN  (* PROCEDURE OpenBackRdr *)
    bR.VAR281 := text;
    bR.VAR28F := FALSE;
    bR.VAR28D := 63;
    IF (pos >= 64) THEN
      bR.VAR289 := (pos - 64);
      i := 0;
      Texts.OpenReader(R, text, bR.VAR289);
    ELSE
      i := SHORT((64 - pos));
      bR.VAR289 := -i;
      Texts.OpenReader(R, text, 0);
    END;  (* IF *)
    bR.VAR28B := i;
    Texts.Read(R, ch);
    WHILE (i < 64) DO
      bR.VAR287[i] := ch;
      INC(i, 1);
      Texts.Read(R, ch);
    END;  (* WHILE *)
  END OpenBackRdr;


  PROCEDURE RPos(VAR bR: BackRdr): LONGINT;

  BEGIN  (* PROCEDURE RPos *)
    IF (bR.VAR28D >= 0) THEN
      RETURN ((bR.VAR289 + LONG(bR.VAR28D)) + 1);
    ELSE
      RETURN bR.VAR289;
    END;  (* IF *)
  END RPos;


  PROCEDURE RemoveMarks(tF: TextFrames.Frame);

  BEGIN  (* PROCEDURE RemoveMarks *)
    TextFrames.RemoveSelection(tF);
    TextFrames.RemoveCaret(tF);
    Oberon.RemoveMarks(tF^.X, tF^.Y, tF^.W, tF^.H);
  END RemoveMarks;


  PROCEDURE SPatFound(tF: TextFrames.Frame; text: Texts.Text; VAR pos: LONGINT): BOOLEAN;

    VAR
      l: LONGINT;
      i: INTEGER;
      ch: CHAR;
      R: Texts.Reader;

  BEGIN  (* PROCEDURE SPatFound *)
    IF (sPatLen > 0) THEN
      IF (tF # NIL) THEN
        TextFrames.Mark(tF, -1);
      END;  (* IF *)
      Texts.OpenReader(R, text, pos);
      Texts.Read(R, ch);
      INC(pos, 1);
      l := text^.len;
      i := 0;
      WHILE (i # sPatLen) & (pos <= l) DO
        IF (ch = sPat[i]) THEN
          INC(i, 1);
          IF (i < sPatLen) THEN
            Texts.Read(R, ch);
            INC(pos, 1);
          END;  (* IF *)
        ELSIF (i = 0) THEN
          Texts.Read(R, ch);
          INC(pos, 1);
        ELSE
          DEC(i, sDv[i]);
        END;  (* IF *)
      END;  (* WHILE *)
      IF (tF # NIL) THEN
        TextFrames.Mark(tF, 1);
      END;  (* IF *)
    ELSE
      i := -1;
    END;  (* IF *)
    RETURN (i = sPatLen);
  END SPatFound;


  PROCEDURE SetCaret(F: Display.Frame; T: Texts.Text; pos: LONGINT);

    VAR
      M: Oberon.CaretMsg;

  BEGIN  (* PROCEDURE SetCaret *)
    M.id := 1;
    M.F := F;
    M.car := F;
    M.text := T;
    M.pos := pos;
    Display.Broadcast(M);
  END SetCaret;


  PROCEDURE ThisFrame(X: INTEGER; Y: INTEGER; VAR F: Display.Frame);

    VAR
      M: Display.LocateMsg;

  BEGIN  (* PROCEDURE ThisFrame *)
    M.X := X;
    M.Y := Y;
    M.F := NIL;
    M.loc := NIL;
    Display.Broadcast(M);
    F := M.loc;
  END ThisFrame;


  PROCEDURE UnMarkMenu(F: TextFrames.Frame);

    VAR
      ch: CHAR;
      V: Viewers.Viewer;
      T: Texts.Text;
      R: Texts.Reader;

  BEGIN  (* PROCEDURE UnMarkMenu *)
    V := Viewers.This(F^.X, F^.Y);
    IF (V IS MenuViewers.Viewer) & (V^.dsc IS TextFrames.Frame) THEN
      T := V^.dsc(TextFrames.Frame)^.text;
      IF (T^.len > 0) THEN
        Texts.OpenReader(R, T, T^.len - 1);
        Texts.Read(R, ch);
      ELSE
        ch := 000X;
      END;  (* IF *)
      IF (ch = "!") THEN
        Texts.Delete(T, T^.len - 2, T^.len);
      END;  (* IF *)
    END;  (* IF *)
  END UnMarkMenu;


  PROCEDURE replace(): BOOLEAN;

    VAR
      time: LONGINT;
      text: Texts.Text;
      tF: TextFrames.Frame;
      tBuf: Texts.Buffer;
      pos: LONGINT;
      p: LONGINT;
      len: LONGINT;
      i: INTEGER;
      end: LONGINT;
      ch: CHAR;
      beg: LONGINT;
      V: Viewers.Viewer;
      T: Texts.Text;
      R: Texts.Reader;

  BEGIN  (* PROCEDURE replace *)
    V := Oberon.MarkedViewer();
    IF ((V^.dsc = NIL) OR ~(V^.dsc^.next IS TextFrames.Frame)) THEN
      RETURN FALSE;
    END;  (* IF *)
    tF := V^.dsc^.next(TextFrames.Frame);
    T := tF^.text;
    text := NIL;
    Oberon.GetSelection(text, beg, end, time);
    IF (text # NIL) & (time > lTime) THEN
      lTime := time;
      NEW(rBuf);
      Texts.OpenBuf(rBuf);
      Texts.Save(text, beg, end, rBuf);
    END;  (* IF *)
    IF (((tF^.car <= 0) OR ~(sPatLen > 0)) OR (rBuf = NIL)) THEN
      RETURN FALSE;
    END;  (* IF *)
    pos := tF^.carloc.pos;
    p := (pos - LONG(sPatLen));
    IF (p < 0) THEN
      RETURN FALSE;
    END;  (* IF *)
    Texts.OpenReader(R, T, p);
    Texts.Read(R, ch);
    i := 0;
    WHILE (ch = sPat[i]) & (i < sPatLen) DO
      Texts.Read(R, ch);
      INC(i, 1);
    END;  (* WHILE *)
    IF (i = sPatLen) THEN
      Texts.Delete(T, p, pos);
      pos := p;
      NEW(tBuf);
      Texts.OpenBuf(tBuf);
      Texts.Copy(rBuf, tBuf);
      len := tBuf^.len;
      Texts.Insert(T, pos, tBuf);
      pos := (pos + len);
    END;  (* IF *)
    IF SPatFound(tF, tF^.text, pos) THEN
      MarkPatPos(tF, pos);
      RETURN TRUE;
    ELSE
      TextFrames.RemoveSelection(tF);
      TextFrames.RemoveCaret(tF);
      RETURN FALSE;
    END;  (* IF *)
  END replace;


  PROCEDURE ChangeColor*();

    VAR
      time: LONGINT;
      par: Oberon.ParList;
      end: LONGINT;
      col: SHORTINT;
      beg: LONGINT;
      T: Texts.Text;
      S: Texts.Scanner;

  BEGIN  (* PROCEDURE ChangeColor *)
    par := Oberon.Par;
    Texts.OpenScanner(S, par^.text, par^.pos);
    Texts.Scan(S);
    IF (S.class # 3) THEN
      col := S.col;
    ELSE
      col := SHORT(SHORT(S.i));
    END;  (* IF *)
    Oberon.GetSelection(T, beg, end, time);
    IF (time >= 0) THEN
      Texts.ChangeLooks(T, beg, end, {1}, NIL, col, 0);
    END;  (* IF *)
  END ChangeColor;


  PROCEDURE ChangeFont*();

    VAR
      par: Oberon.ParList;
      end: LONGINT;
      beg: LONGINT;
      T: Texts.Text;
      S: Texts.Scanner;

  BEGIN  (* PROCEDURE ChangeFont *)
    Oberon.GetSelection(T, beg, end, time);
    IF (time >= 0) THEN
      par := Oberon.Par;
      Texts.OpenScanner(S, par^.text, par^.pos);
      Texts.Scan(S);
      IF (S.class = 1) THEN
        Texts.ChangeLooks(T, beg, end, {0}, Fonts.This(S.s), 0, 0);
      END;  (* IF *)
    END;  (* IF *)
  END ChangeFont;


  PROCEDURE Clear*();

    VAR
      tF: TextFrames.Frame;
      V: Viewers.Viewer;

  BEGIN  (* PROCEDURE Clear *)
    V := Oberon.Par^.vwr;
    IF (V^.dsc # Oberon.Par^.frame) THEN
      V := Oberon.MarkedViewer();
    END;  (* IF *)
    IF (V^.dsc # NIL) & (V^.dsc^.next IS TextFrames.Frame) THEN
      tF := V^.dsc^.next(TextFrames.Frame);
      Texts.Delete(tF^.text, 0, tF^.text^.len);
    END;  (* IF *)
  END Clear;


  PROCEDURE CopyFont*();

    VAR
      v: Viewers.Viewer;
      end: LONGINT;
      ch: CHAR;
      beg: LONGINT;
      Y: INTEGER;
      X: INTEGER;
      T: Texts.Text;
      R: Texts.Reader;
      F: Display.Frame;

  BEGIN  (* PROCEDURE CopyFont *)
    v := Oberon.MarkedViewer();
    F := v^.dsc;
    X := Oberon.Pointer.X;
    Y := Oberon.Pointer.Y;
    LOOP
      IF (F = NIL) THEN
        EXIT;
      END;  (* IF *)
      IF (X >= F^.X) & (X < (F^.X + F^.W)) & (Y >= F^.Y) & (Y < (F^.Y + F^.H)) THEN
        IF (F IS TextFrames.Frame) THEN
          WITH F: TextFrames.Frame DO
            Texts.OpenReader(R, F^.text, TextFrames.Pos(F, X, Y));
            Texts.Read(R, ch);
            Oberon.GetSelection(T, beg, end, time);
            IF (time >= 0) THEN
              Texts.ChangeLooks(T, beg, end, {0}, R.lib, 0, 0);
            END;  (* IF *)
          END;  (* WITH *)
        END;  (* IF *)
        EXIT;
      END;  (* IF *)
      F := F^.next;
    END;  (* LOOP *)
  END CopyFont;


  PROCEDURE Error*();

    TYPE
      ARRAY1A1A = ARRAY OF CHAR;

    VAR
      time: LONGINT;
      text: Texts.Text;
      pos: LONGINT;
      i: INTEGER;
      end: LONGINT;
      beg: LONGINT;
      Y: INTEGER;
      X: INTEGER;
      V: Viewers.Viewer;
      S: Texts.Scanner;

    (* Forward PROCEDURE declarations *)

    PROCEDURE^ OpenScanner(VAR S: Texts.Scanner; text: Texts.Text; pos: LONGINT);
    PROCEDURE^ OpenViewer(text: Texts.Text; title: ARRAY1A1A; pos: LONGINT; X: INTEGER; Y: INTEGER; kind: SHORTINT): Viewers.Viewer;

    PROCEDURE OpenScanner(VAR S: Texts.Scanner; text: Texts.Text; pos: LONGINT);

    BEGIN  (* PROCEDURE OpenScanner *)
      S.line := 0;
      IF (text = NIL) THEN
        S.class := -1;
      ELSE
        Texts.OpenReader(S, text, pos);
        Texts.Read(S, S.nextCh);
        S.class := 0;
      END;  (* IF *)
    END OpenScanner;


    PROCEDURE OpenViewer(text: Texts.Text; title: ARRAY1A1A; pos: LONGINT; X: INTEGER; Y: INTEGER; kind: SHORTINT): Viewers.Viewer;

      VAR
        mainF: TextFrames.Frame;
        mF: TextFrames.Frame;

    BEGIN  (* PROCEDURE OpenViewer *)
      mF := TextFrames.NewMenu(title, "System.Close System.Copy System.Grow Edit.Search Edit.Replace Edit.Store");
      mainF := TextFrames.NewText(text, pos);
      RETURN MenuViewers.New(mF, mainF, TextFrames.menuH, X, Y);
    END OpenViewer;


  BEGIN  (* PROCEDURE Error *)
    text := NIL;
    Oberon.GetSelection(text, beg, end, time);
    IF (text # NIL) & (time > 0) THEN
      OpenScanner(S, text, beg);
      Texts.Scan(S);
      REPEAT
        Texts.Scan(S);
      UNTIL ((S.class = 1) & (S.s = "err") OR (S.class > 3));
      IF (S.class = 1) & (S.s = "err") THEN
        text := TextFrames.Text("OberonErrors.Text");
        IF (text^.len > 0) THEN
          i := 0;
          WHILE (S.nextCh = " ") DO
            Texts.Read(S, S.nextCh);
          END;  (* WHILE *)
          WHILE ("0" <= S.nextCh) & (S.nextCh <= "9") DO
            sPat[i] := S.nextCh;
            INC(i, 1);
            Texts.Read(S, S.nextCh);
          END;  (* WHILE *)
          sPat[i] := 009X;
          INC(i, 1);
          sPatLen := i;
          pos := 0;
          CalcDispVec(Oberon.Time());
          IF SPatFound(NIL, text, pos) THEN
            Oberon.AllocateUserViewer(Oberon.UserTrack(Oberon.Par^.vwr^.X), X, Y);
            V := OpenViewer(text, "OberonErrors.Text", LinesUp(text, pos, 4), X, Y, 0);
            IF (pos > 0) THEN
              Oberon.Defocus();
              TextFrames.SetCaret(V^.dsc^.next(TextFrames.Frame), pos);
            END;  (* IF *)
          END;  (* IF *)
        END;  (* IF *)
      END;  (* IF *)
    END;  (* IF *)
  END Error;


  PROCEDURE Locate*();

    VAR
      time: LONGINT;
      text: Texts.Text;
      end: LONGINT;
      beg: LONGINT;
      T: Texts.Text;
      S: Texts.Scanner;
      F: Display.Frame;

  BEGIN  (* PROCEDURE Locate *)
    text := GetText(F);
    IF (text # NIL) THEN
      Oberon.GetSelection(T, beg, end, time);
      IF (time >= 0) THEN
        Texts.OpenScanner(S, T, beg);
        REPEAT
          Texts.Scan(S);
        UNTIL (S.class >= 3);
        IF (S.class = 3) THEN
          SetCaret(F, text, S.i);
        END;  (* IF *)
      END;  (* IF *)
    END;  (* IF *)
  END Locate;


  PROCEDURE Open*();

    VAR
      time: LONGINT;
      tF: TextFrames.Frame;
      par: Oberon.ParList;
      end: LONGINT;
      beg: LONGINT;
      Y: INTEGER;
      X: INTEGER;
      V: Viewers.Viewer;
      T: Texts.Text;
      S: Texts.Scanner;

  BEGIN  (* PROCEDURE Open *)
    par := Oberon.Par;
    Texts.OpenScanner(S, par^.text, par^.pos);
    Texts.Scan(S);
    IF ((S.class = 6) & (S.c = "^") OR (S.line # 0)) THEN
      Oberon.GetSelection(T, beg, end, time);
      IF (time >= 0) THEN
        Texts.OpenScanner(S, T, beg);
        Texts.Scan(S);
      ELSE
        S.class := 1;
        S.s := ".Text";
      END;  (* IF *)
    END;  (* IF *)
    IF (S.class = 1) THEN
      Oberon.AllocateUserViewer(par^.vwr^.X, X, Y);
      tF := TextFrames.NewText(TextFrames.Text(S.s), 0);
      tF^.handle := (Handler);
      V := MenuViewers.New(TextFrames.NewMenu(S.s, "System.Close System.Copy System.Grow Edit.Search Edit.Replace Edit.Store"), tF, TextFrames.menuH, X, Y);
    END;  (* IF *)
  END Open;


  PROCEDURE Print*();

    TYPE
      ARRAY15D3 = ARRAY 32 OF CHAR;

    VAR
      time: LONGINT;
      source: Texts.Text;
      server: ARRAY15D3;
      par: Oberon.ParList;
      pageno: SHORTINT;
      options: ARRAY15D3;
      nofcopies: INTEGER;
      lsp: INTEGER;
      listing: BOOLEAN;
      lib: Objects.Library;
      len: INTEGER;
      j: INTEGER;
      id: CHAR;
      i: INTEGER;
      font: Fonts.Font;
      end: LONGINT;
      ch: CHAR;
      beg: LONGINT;
      Y: INTEGER;
      V: Viewers.Viewer;
      Text: TextFrames.Frame;
      T: Texts.Text;
      S: Texts.Scanner;
      R: Texts.Reader;
      Menu: TextFrames.Frame;

    (* Forward PROCEDURE declarations *)

    PROCEDURE^ Option();
    PROCEDURE^ PrintUnit(source: Texts.Text; pos: LONGINT);
    PROCEDURE^ SendHeader();

    PROCEDURE Option();

      VAR
        ch: CHAR;

    BEGIN  (* PROCEDURE Option *)
      nofcopies := 1;
      IF ((S.nextCh = "%") OR (S.nextCh = Oberon.OptionChar)) THEN
        Texts.Read(S, ch);
        IF (ch >= "0") & (ch <= "9") THEN
          nofcopies := (ORD(ch) - 48);
        END;  (* IF *)
        WHILE (ch > " ") DO
          Texts.Read(S, ch);
        END;  (* WHILE *)
        S.nextCh := ch;
      END;  (* IF *)
    END Option;


    PROCEDURE PrintUnit(source: Texts.Text; pos: LONGINT);

      TYPE
        ARRAY16E9 = ARRAY 200 OF CHAR;

      VAR
        new: BOOLEAN;
        i: INTEGER;
        buf: ARRAY16E9;

    BEGIN  (* PROCEDURE PrintUnit *)
      Texts.WriteString(W, S.s);
      IF (source^.len # 0) THEN
        Texts.WriteString(W, " printing");
        Texts.WriteInt(W, nofcopies, 3);
        Texts.Append(Oberon.Log, W.buf);
        lsp := ASH(Fonts.Default^.height * 7, -1);
        pageno := 0;
        SendHeader();
        Y := topY;
        Texts.OpenReader(R, source, pos);
        IF ~listing THEN
          REPEAT
            Texts.Read(R, ch);
            new := TRUE;
            lib := R.lib;
            WHILE ~R.eot & (ch # 00DX) DO
              i := 0;
              REPEAT
                IF (ch = 009X) THEN
                  ch := " ";
                  buf[i] := ch;
                  INC(i, 1);
                  buf[i] := ch;
                  INC(i, 1);
                  buf[i] := ch;
                  INC(i, 1);
                END;  (* IF *)
                buf[i] := ch;
                INC(i, 1);
                Texts.Read(R, ch);
              UNTIL ((R.eot OR (ch = 00DX)) OR (R.lib # lib));
              buf[i] := 000X;
              IF new THEN
                Printer.String(textX, Y, buf, lib(Fonts.Font));
              ELSE
                Printer.ContString(buf, lib(Fonts.Font));
              END;  (* IF *)
              new := FALSE;
              lib := R.lib;
            END;  (* WHILE *)
            Y := (Y - lsp);
            IF (Y < botY) THEN
              Printer.Page(nofcopies);
              INC(pageno, 1);
              SendHeader();
              Y := topY;
            END;  (* IF *)
          UNTIL R.eot;
        ELSE
          lsp := 32;
          REPEAT
            Texts.Read(R, ch);
            WHILE ~R.eot & (ch # 00DX) DO
              i := 0;
              REPEAT
                IF (ch = 009X) THEN
                  ch := " ";
                  buf[i] := ch;
                  INC(i, 1);
                  buf[i] := ch;
                  INC(i, 1);
                  buf[i] := ch;
                  INC(i, 1);
                END;  (* IF *)
                buf[i] := ch;
                INC(i, 1);
                Texts.Read(R, ch);
              UNTIL (R.eot OR (ch = 00DX));
              buf[i] := 000X;
              Printer.String(textX, Y, buf, Fonts.Default);
            END;  (* WHILE *)
            Y := (Y - lsp);
            IF (Y < botY) THEN
              Printer.Page(nofcopies);
              INC(pageno, 1);
              SendHeader();
              Y := topY;
            END;  (* IF *)
          UNTIL R.eot;
        END;  (* IF *)
        IF (Y < topY) THEN
          Printer.Page(nofcopies);
        END;  (* IF *)
      ELSE
        Texts.WriteString(W, " not found");
      END;  (* IF *)
      Texts.WriteLn(W);
      Texts.Append(Oberon.Log, W.buf);
    END PrintUnit;


    PROCEDURE SendHeader();

      TYPE
        ARRAY168F = ARRAY 4 OF CHAR;

      VAR
        pno: ARRAY168F;

    BEGIN  (* PROCEDURE SendHeader *)
      Printer.String(textX, headerY, S.s, Fonts.Default);
      IF (pageno DIV 10 = 0) THEN
        pno[0] := " ";
      ELSE
        pno[0] := CHR((pageno DIV 10 + 48));
      END;  (* IF *)
      pno[1] := CHR((pageno MOD 10 + 48));
      pno[2] := 000X;
      Printer.String(pagenoX, headerY, pno, Fonts.Default);
    END SendHeader;


  BEGIN  (* PROCEDURE Print *)
    par := Oberon.Par;
    Texts.WriteString(W, "Edit.Print");
    Texts.WriteLn(W);
    Texts.Append(Oberon.Log, W.buf);
    Texts.OpenScanner(S, par^.text, par^.pos);
    Texts.Scan(S);
    IF (S.class = 1) THEN
      COPY(S.s, server);
      IF (S.nextCh = Oberon.OptionChar) THEN
        Texts.Scan(S);
        Texts.Scan(S);
        IF ((S.class = 1) OR (S.class = 2)) THEN
          COPY(S.s, options);
        ELSE
          options[0] := 000X;
        END;  (* IF *)
      ELSE
        options[0] := 000X;
      END;  (* IF *)
      Printer.Open(server, options);
      IF (Printer.res = 0) THEN
        GetPageSize();
        Texts.Scan(S);
        IF (S.class = 6) & (S.c = "%") THEN
          listing := TRUE;
          Printer.UseListFont(Fonts.Default^.name);
          Texts.Scan(S);
        ELSE
          listing := FALSE;
        END;  (* IF *)
        IF (S.class = 6) & (S.c = "*") THEN
          Option();
          V := Oberon.MarkedViewer();
          IF (V^.dsc IS TextFrames.Frame) & (V^.dsc^.next IS TextFrames.Frame) THEN
            Menu := V^.dsc(TextFrames.Frame);
            Text := V^.dsc^.next(TextFrames.Frame);
            Texts.OpenScanner(S, Menu^.text, 0);
            Texts.Scan(S);
            TextFrames.Mark(Text, -1);
            PrintUnit(Text^.text, 0);
            TextFrames.Mark(Text, 1);
          END;  (* IF *)
        ELSE
          WHILE (S.class = 1) DO
            Option();
            NEW(source);
            Texts.Open(source, S.s);
            PrintUnit(source, 0);
            Texts.Scan(S);
          END;  (* WHILE *)
          IF (S.class = 6) & (S.c = "^") THEN
            Oberon.GetSelection(T, beg, end, time);
            IF (time >= 0) THEN
              Texts.OpenScanner(S, T, beg);
              Texts.Scan(S);
              IF (S.class = 1) THEN
                Option();
                NEW(source);
                Texts.Open(source, S.s);
                PrintUnit(source, 0);
              END;  (* IF *)
            END;  (* IF *)
          END;  (* IF *)
        END;  (* IF *)
        Printer.Close();
      ELSE
        IF (Printer.res = 1) THEN
          Texts.WriteString(W, " no such printer");
        ELSIF (Printer.res = 2) THEN
          Texts.WriteString(W, " no link");
        ELSIF (Printer.res = 3) THEN
          Texts.WriteString(W, " printer not ready");
        ELSIF (Printer.res = 4) THEN
          Texts.WriteString(W, " no permission");
        END;  (* IF *)
        Texts.WriteLn(W);
        Texts.Append(Oberon.Log, W.buf);
      END;  (* IF *)
    ELSE
      Texts.WriteString(W, " no printer specified");
      Texts.WriteLn(W);
      Texts.Append(Oberon.Log, W.buf);
    END;  (* IF *)
  END Print;


  PROCEDURE Recall*();

    VAR
      M: Oberon.RecallMsg;

  BEGIN  (* PROCEDURE Recall *)
    M.F := NIL;
    Display.Broadcast(M);
  END Recall;


  PROCEDURE Replace*();

  BEGIN  (* PROCEDURE Replace *)
    IF replace() THEN
    END;  (* IF *)
  END Replace;


  PROCEDURE ReplaceAll*();

  BEGIN  (* PROCEDURE ReplaceAll *)
    WHILE replace() DO
    END;  (* WHILE *)
  END ReplaceAll;


  PROCEDURE Search*();

    VAR
      time: LONGINT;
      text: Texts.Text;
      tF: TextFrames.Frame;
      pos: LONGINT;
      j: INTEGER;
      i: INTEGER;
      end: LONGINT;
      d: INTEGER;
      beg: LONGINT;
      V: Viewers.Viewer;
      R: Texts.Reader;

  BEGIN  (* PROCEDURE Search *)
    IF (Oberon.Par^.vwr # NIL) & (Oberon.Par^.frame = Oberon.Par^.vwr^.dsc) THEN
      V := Oberon.Par^.vwr;
    ELSE
      V := Oberon.MarkedViewer();
    END;  (* IF *)
    IF ((V^.dsc = NIL) OR ~(V^.dsc^.next IS TextFrames.Frame)) THEN
      RETURN;
    END;  (* IF *)
    tF := V^.dsc^.next(TextFrames.Frame);
    text := NIL;
    Oberon.GetSelection(text, beg, end, time);
    IF (text # NIL) & (time > lTime) THEN
      Texts.OpenReader(R, text, beg);
      i := 0;
      pos := beg;
      REPEAT
        Texts.Read(R, sPat[i]);
        INC(i, 1);
        INC(pos, 1);
      UNTIL ((i = 128) OR (pos = end));
      sPatLen := i;
      CalcDispVec(time);
    END;  (* IF *)
    IF (tF^.car > 0) THEN
      pos := tF^.carloc.pos;
    ELSE
      pos := 0;
    END;  (* IF *)
    IF SPatFound(tF, tF^.text, pos) THEN
      MarkPatPos(tF, pos);
    ELSE
      TextFrames.RemoveSelection(tF);
      TextFrames.RemoveCaret(tF);
    END;  (* IF *)
  END Search;


  PROCEDURE Show*();

    TYPE
      ARRAYCCD = ARRAY 32 OF CHAR;
      ARRAYCDC = ARRAY 35 OF CHAR;
      ARRAYCF7 = ARRAY 256 OF INTEGER;
      ARRAYCFD = ARRAY 32 OF CHAR;

    VAR
      time: LONGINT;
      tF: TextFrames.Frame;
      t: Texts.Text;
      pos: LONGINT;
      pat: ARRAYCCD;
      par: Oberon.ParList;
      name: ARRAYCDC;
      n: INTEGER;
      len: LONGINT;
      j: INTEGER;
      i: INTEGER;
      end: LONGINT;
      d: ARRAYCF7;
      buf: ARRAYCFD;
      beg: LONGINT;
      Y: INTEGER;
      X: INTEGER;
      V: Viewers.Viewer;
      T: Texts.Text;
      S: Texts.Scanner;
      R: Texts.Reader;
      M: INTEGER;


    PROCEDURE Forward(n: INTEGER);

      VAR
        m: INTEGER;
        j: INTEGER;

    BEGIN  (* PROCEDURE Forward *)
      m := (M - n);
      j := 0;
      WHILE (j # m) DO
        buf[j] := buf[(n + j)];
        INC(j, 1);
      END;  (* WHILE *)
      WHILE (j # M) DO
        Texts.Read(R, buf[j]);
        INC(j, 1);
      END;  (* WHILE *)
    END Forward;


  BEGIN  (* PROCEDURE Show *)
    par := Oberon.Par;
    Texts.OpenScanner(S, par^.text, par^.pos);
    Texts.Scan(S);
    IF ((S.class = 6) & (S.c = "^") OR (S.line # 0)) THEN
      Oberon.GetSelection(T, beg, end, time);
      IF (time >= 0) THEN
        Texts.OpenScanner(S, T, beg);
        Texts.Scan(S);
      END;  (* IF *)
    END;  (* IF *)
    IF (S.class = 1) THEN
      i := -1;
      j := 0;
      WHILE (S.s[j] # 000X) DO
        IF (S.s[j] = ".") THEN
          i := j;
        END;  (* IF *)
        name[j] := S.s[j];
        j := (j + 1);
      END;  (* WHILE *)
      IF (i < 0) THEN
        name[j] := ".";
        i := j;
      END;  (* IF *)
      name[(i + 1)] := "M";
      name[(i + 2)] := "o";
      name[(i + 3)] := "d";
      name[(i + 4)] := 000X;
      t := TextFrames.Text(name);
      IF (j > i) THEN
        j := (i + 1);
        M := 0;
        WHILE (M # 32) & (S.s[j] # 000X) DO
          pat[M] := S.s[j];
          j := (j + 1);
          M := (M + 1);
        END;  (* WHILE *)
        j := 0;
        WHILE (j # 256) DO
          d[j] := M;
          INC(j, 1);
        END;  (* WHILE *)
        j := 0;
        WHILE (j # (M - 1)) DO
          d[ORD(pat[j])] := ((M - 1) - j);
          INC(j, 1);
        END;  (* WHILE *)
        pos := 0;
        len := t^.len;
        Texts.OpenReader(R, t, pos);
        Forward(M);
        pos := (pos + LONG(M));
        LOOP
          j := M;
          REPEAT
            DEC(j, 1);
          UNTIL ((j < 0) OR (buf[j] # pat[j]));
          IF ((j < 0) OR (pos >= len)) THEN
            EXIT;
          END;  (* IF *)
          n := d[ORD(buf[(M - 1)])];
          Forward(n);
          pos := (pos + LONG(n));
        END;  (* LOOP *)
      ELSE
        pos := 0;
      END;  (* IF *)
      Oberon.AllocateUserViewer(par^.vwr^.X, X, Y);
      tF := TextFrames.NewText(t, pos - 200);
      tF^.handle := (Handler);
      V := MenuViewers.New(TextFrames.NewMenu(name, "System.Close System.Copy System.Grow Edit.Search Edit.Replace Edit.Store"), tF, TextFrames.menuH, X, Y);
    END;  (* IF *)
  END Show;


  PROCEDURE Store*();

    TYPE
      ARRAYEFA = ARRAY OF CHAR;

    VAR
      time: LONGINT;
      par: Oberon.ParList;
      len: LONGINT;
      f: Files.File;
      end: LONGINT;
      beg: LONGINT;
      V: Viewers.Viewer;
      Text: TextFrames.Frame;
      T: Texts.Text;
      S: Texts.Scanner;


    PROCEDURE Backup(VAR name: ARRAYEFA);

      TYPE
        ARRAYF0D = ARRAY 32 OF CHAR;

      VAR
        res: INTEGER;
        i: INTEGER;
        bak: ARRAYF0D;

    BEGIN  (* PROCEDURE Backup *)
      i := 0;
      WHILE (name[i] # 000X) DO
        bak[i] := name[i];
        INC(i, 1);
      END;  (* WHILE *)
      bak[i] := ".";
      bak[(i + 1)] := "B";
      bak[(i + 2)] := "a";
      bak[(i + 3)] := "k";
      bak[(i + 4)] := 000X;
      Files.Rename(name, bak, res);
    END Backup;


  BEGIN  (* PROCEDURE Store *)
    Texts.WriteString(W, "Edit.Store ");
    par := Oberon.Par;
    IF (par^.frame = par^.vwr^.dsc) THEN
      V := par^.vwr;
      Texts.OpenScanner(S, V^.dsc(TextFrames.Frame)^.text, 0);
    ELSE
      V := Oberon.MarkedViewer();
      Texts.OpenScanner(S, par^.text, par^.pos);
    END;  (* IF *)
    Texts.Scan(S);
    IF (S.class = 6) & (S.c = "^") THEN
      Oberon.GetSelection(T, beg, end, time);
      IF (time >= 0) THEN
        Texts.OpenScanner(S, T, beg);
        Texts.Scan(S);
      END;  (* IF *)
    END;  (* IF *)
    IF (S.class = 1) & (V^.dsc # NIL) & (V^.dsc^.next IS TextFrames.Frame) THEN
      Text := V^.dsc^.next(TextFrames.Frame);
      TextFrames.Mark(Text, -1);
      UnMarkMenu(Text);
      Texts.WriteString(W, S.s);
      Texts.WriteLn(W);
      Texts.Append(Oberon.Log, W.buf);
      Backup(S.s);
      f := Files.New(S.s);
      Texts.Store(Text^.text, f, 0, len);
      Files.Register(f);
      TextFrames.Mark(Text, 1);
    END;  (* IF *)
  END Store;


BEGIN  (* MODULE Edit *)
  Texts.OpenWriter(W);
  InitPattern();
  GetPageSize();
END Edit.
